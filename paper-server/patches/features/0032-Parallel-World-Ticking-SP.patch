From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peter Pan <peter@never.lan>
Date: Mon, 28 Jul 2025 13:18:12 -0400
Subject: [PATCH] Parallel World Ticking SP


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index b5817aa8f537593f6d9fc6b612c82ccccb250ac7..6d8ccc00868d38afe5bcf9eacad0221f56e7ce92 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -116,10 +116,10 @@ public final class ChunkHolderManager {
         final List<NewChunkHolder> changedFullStatus = new ArrayList<>();
         final boolean ret;
         final ReentrantAreaLock.Node ticketLock = this.ticketLockArea.lock(
-                            ((posX >> ticketShift) - 1) << ticketShift,
-                            ((posZ >> ticketShift) - 1) << ticketShift,
-                            (((posX >> ticketShift) + 1) << ticketShift) | ticketMask,
-                            (((posZ >> ticketShift) + 1) << ticketShift) | ticketMask
+            ((posX >> ticketShift) - 1) << ticketShift,
+            ((posZ >> ticketShift) - 1) << ticketShift,
+            (((posX >> ticketShift) + 1) << ticketShift) | ticketMask,
+            (((posZ >> ticketShift) + 1) << ticketShift) | ticketMask
         );
         try {
             ret = this.processTicketUpdatesNoLock(posX >> ticketShift, posZ >> ticketShift, scheduledTasks, changedFullStatus);
@@ -139,7 +139,7 @@ public final class ChunkHolderManager {
     private boolean processTicketUpdatesNoLock(final int sectionX, final int sectionZ, final List<ChunkProgressionTask> scheduledTasks,
                                                final List<NewChunkHolder> changedFullStatus) {
         return this.ticketLevelPropagator.performUpdate(
-                sectionX, sectionZ, this.taskScheduler.schedulingLockArea, scheduledTasks, changedFullStatus
+            sectionX, sectionZ, this.taskScheduler.schedulingLockArea, scheduledTasks, changedFullStatus
         );
     }
 
@@ -320,9 +320,9 @@ public final class ChunkHolderManager {
                 if ((currTime - lastLog) > TimeUnit.SECONDS.toNanos(10L)) {
                     lastLog = currTime;
                     LOGGER.info(
-                            "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
-                                    + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "', progress: "
-                                    + format.format((double)(i+1)/(double)len * 100.0)
+                        "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
+                            + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "', progress: "
+                            + format.format((double)(i+1)/(double)len * 100.0)
                     );
                 }
             }
@@ -337,9 +337,9 @@ public final class ChunkHolderManager {
         }
         if (logProgress) {
             LOGGER.info(
-                    "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
-                            + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "' in "
-                            + format.format(1.0E-9 * (System.nanoTime() - start)) + "s"
+                "Saved " + savedChunk + " block chunks, " + savedEntity + " entity chunks, " + savedPoi
+                    + " poi chunks in world '" + WorldUtil.getWorldName(this.world) + "' in "
+                    + format.format(1.0E-9 * (System.nanoTime() - start)) + "s"
             );
         }
     }
@@ -700,13 +700,13 @@ public final class ChunkHolderManager {
         for (final PrimitiveIterator.OfLong iterator = this.tickets.keyIterator(); iterator.hasNext();) {
             final long coord = iterator.nextLong();
             sections.computeIfAbsent(
-                    CoordinateUtils.getChunkKey(
-                            CoordinateUtils.getChunkX(coord) >> sectionShift,
-                            CoordinateUtils.getChunkZ(coord) >> sectionShift
-                    ),
-                    (final long keyInMap) -> {
-                        return new LongArrayList();
-                    }
+                CoordinateUtils.getChunkKey(
+                    CoordinateUtils.getChunkX(coord) >> sectionShift,
+                    CoordinateUtils.getChunkZ(coord) >> sectionShift
+                ),
+                (final long keyInMap) -> {
+                    return new LongArrayList();
+                }
             ).add(coord);
         }
 
@@ -1031,7 +1031,7 @@ public final class ChunkHolderManager {
         if (changedFullStatus.isEmpty()) {
             return;
         }
-        if (!TickThread.isTickThread()) {
+        if (!TickThread.isTickThreadFor(world)) { // SparklyPaper - parallel world ticking
             this.taskScheduler.scheduleChunkTask(() -> {
                 final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
@@ -1057,7 +1057,7 @@ public final class ChunkHolderManager {
 
     // note: never call while inside the chunk system, this will absolutely break everything
     public void processUnloads() {
-        TickThread.ensureTickThread("Cannot unload chunks off-main");
+        TickThread.ensureTickThread(world, "Cannot unload chunks off-main"); // SparklyPaper - parallel world ticking
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
@@ -1339,7 +1339,7 @@ public final class ChunkHolderManager {
 
         List<NewChunkHolder> changedFullStatus = null;
 
-        final boolean isTickThread = TickThread.isTickThread();
+        final boolean isTickThread = TickThread.isTickThreadFor(world);
 
         boolean ret = false;
         final boolean canProcessFullUpdates = processFullUpdates & isTickThread;
@@ -1418,7 +1418,7 @@ public final class ChunkHolderManager {
         ret.add("tickets", allTicketsJson);
 
         for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.entryIterator();
-            iterator.hasNext();) {
+             iterator.hasNext();) {
             final ConcurrentLong2ReferenceChainedHashTable.TableEntry<SortedArraySet<Ticket<?>>> coordinateTickets = iterator.next();
             final long coordinate = coordinateTickets.getKey();
             final SortedArraySet<Ticket<?>> tickets = coordinateTickets.getValue();
diff --git a/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java b/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
index 4a881636ba21fae9e50950bbba2b4321b71d35ab..ef76ff3671d38b482ac9932560e574d0d8cd9318 100644
--- a/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
@@ -46,7 +46,7 @@ public class BoatDispenseItemBehavior extends DefaultDispenseItemBehavior {
         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleItemStack);
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(d1, d2 + d4, d3));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             serverLevel.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java b/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
index bd5bbc7e55c6bea77991fe5a3c0c2580313d16c5..a231e08edba33bd55bed9a34129615f5e6dddb4d 100644
--- a/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
@@ -78,7 +78,7 @@ public class DefaultDispenseItemBehavior implements DispenseItemBehavior {
         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack);
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(itemEntity.getDeltaMovement()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             level.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/net/minecraft/core/dispenser/DispenseItemBehavior.java b/net/minecraft/core/dispenser/DispenseItemBehavior.java
index 717c84165d5e25cd384f56b7cb976abf6669b6f0..56983dd2148abf0e6a767fe474b98d178ad6727b 100644
--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -89,7 +89,7 @@ public interface DispenseItemBehavior {
                 org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleItemStack);
 
                 org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     serverLevel.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -147,7 +147,7 @@ public interface DispenseItemBehavior {
                     org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleItemStack);
 
                     org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         serverLevel.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -201,7 +201,7 @@ public interface DispenseItemBehavior {
                         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleItemStack);
 
                         org.bukkit.event.block.BlockDispenseArmorEvent event = new org.bukkit.event.block.BlockDispenseArmorEvent(block, craftItem.clone(), entitiesOfClass.get(0).getBukkitLivingEntity());
-                        if (!DispenserBlock.eventFired) {
+                        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                             world.getCraftServer().getPluginManager().callEvent(event);
                         }
 
@@ -251,7 +251,7 @@ public interface DispenseItemBehavior {
                             org.bukkit.block.Block block = org.bukkit.craftbukkit.block.CraftBlock.at(world, blockSource.pos());
                             org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleCopy);
                             org.bukkit.event.block.BlockDispenseArmorEvent event = new org.bukkit.event.block.BlockDispenseArmorEvent(block, craftItem.clone(), abstractChestedHorse.getBukkitLivingEntity());
-                            if (!DispenserBlock.eventFired) {
+                            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                                 world.getCraftServer().getPluginManager().callEvent(event);
                             }
 
@@ -324,12 +324,12 @@ public interface DispenseItemBehavior {
                 /* Taken from BucketItem#emptyContents */
                 boolean willEmptyBucketItem = dispensibleContainerItem instanceof final net.minecraft.world.item.BucketItem bucketItem && bucketItem.content instanceof net.minecraft.world.level.material.FlowingFluid && (iblockdata.isAir() || iblockdata.canBeReplaced(bucketItem.content) || (iblockdata.getBlock() instanceof net.minecraft.world.level.block.LiquidBlockContainer liquidBlockContainer && liquidBlockContainer.canPlaceLiquid(null, level, blockPos, iblockdata, bucketItem.content)));
                 if (willEmptyContentsSolidBucketItem || willEmptyBucketItem) {
-                // Paper end - correctly check if the bucket place will succeed
+                    // Paper end - correctly check if the bucket place will succeed
                     org.bukkit.block.Block block = org.bukkit.craftbukkit.block.CraftBlock.at(level, blockSource.pos());
                     org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
                     org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(x, y, z));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         level.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -389,7 +389,7 @@ public interface DispenseItemBehavior {
                         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
                         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(blockPos));
-                        if (!DispenserBlock.eventFired) {
+                        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                             levelAccessor.getMinecraftWorld().getCraftServer().getPluginManager().callEvent(event);
                         }
 
@@ -425,7 +425,7 @@ public interface DispenseItemBehavior {
                 org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item); // Paper - ignore stack size on damageable items
 
                 org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     serverLevel.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -482,7 +482,7 @@ public interface DispenseItemBehavior {
                 org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
                 org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     level.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -510,8 +510,8 @@ public interface DispenseItemBehavior {
                 // CraftBukkit start
                 level.captureTreeGeneration = false;
                 if (level.capturedBlockStates.size() > 0) {
-                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                    net.minecraft.world.level.block.SaplingBlock.treeType = null;
+                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                    net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(blockPos, level.getWorld());
                     List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(level.capturedBlockStates.values());
                     level.capturedBlockStates.clear();
@@ -548,7 +548,7 @@ public interface DispenseItemBehavior {
                 org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(singleItemStack);
 
                 org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) blockPos.getX() + 0.5D, (double) blockPos.getY(), (double) blockPos.getZ() + 0.5D));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     level.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -591,7 +591,7 @@ public interface DispenseItemBehavior {
                     org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
                     org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(blockPos));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         level.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -644,7 +644,7 @@ public interface DispenseItemBehavior {
                 org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
                 org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(blockPos));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     level.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -702,7 +702,7 @@ public interface DispenseItemBehavior {
                     org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - only single item in event
 
                     org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(blockPos));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         serverLevel.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -721,9 +721,9 @@ public interface DispenseItemBehavior {
                     }
                     // CraftBukkit end
                     if (blockState.is(
-                            BlockTags.BEEHIVES,
-                            blockStateBase -> blockStateBase.hasProperty(BeehiveBlock.HONEY_LEVEL) && blockStateBase.getBlock() instanceof BeehiveBlock
-                        )
+                        BlockTags.BEEHIVES,
+                        blockStateBase -> blockStateBase.hasProperty(BeehiveBlock.HONEY_LEVEL) && blockStateBase.getBlock() instanceof BeehiveBlock
+                    )
                         && blockState.getValue(BeehiveBlock.HONEY_LEVEL) >= 5) {
                         ((BeehiveBlock)blockState.getBlock())
                             .releaseBeesAndResetHoneyLevel(serverLevel, blockState, blockPos, null, BeehiveBlockEntity.BeeReleaseStatus.BEE_RELEASED);
@@ -783,7 +783,7 @@ public interface DispenseItemBehavior {
                     org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item); // Paper - ignore stack size on damageable items
 
                     org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseArmorEvent(block, craftItem.clone(), entitiesOfClass.get(0).getBukkitLivingEntity());
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         serverLevel.getCraftServer().getPluginManager().callEvent(event);
                     }
 
diff --git a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
index 3595bbd05fb3e8fe57e38d4e2df5c6237046b726..2b02d7cbc7fbb916c240f2d16bab365dbc1b8e56 100644
--- a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
@@ -39,7 +39,7 @@ public class EquipmentDispenseItemBehavior extends DefaultDispenseItemBehavior {
             org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemStack);
 
             org.bukkit.event.block.BlockDispenseArmorEvent event = new org.bukkit.event.block.BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) livingEntity.getBukkitEntity());
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                 world.getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/net/minecraft/core/dispenser/MinecartDispenseItemBehavior.java b/net/minecraft/core/dispenser/MinecartDispenseItemBehavior.java
index 116395b6c00a0814922516707544a9ff26d68835..672ebd0cfc144d9b7315dcebf1e8007912ad7412 100644
--- a/net/minecraft/core/dispenser/MinecartDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/MinecartDispenseItemBehavior.java
@@ -62,7 +62,7 @@ public class MinecartDispenseItemBehavior extends DefaultDispenseItemBehavior {
         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack1);
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block2, craftItem.clone(), new org.bukkit.util.Vector(vec31.x, vec31.y, vec31.z));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             serverLevel.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java b/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
index 449d9b72ff4650961daa9d1bd25940f3914a6b12..df07b55924c1edca11eebd9debc75d9f184ede9d 100644
--- a/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
+++ b/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
@@ -32,7 +32,7 @@ public class ProjectileDispenseBehavior extends DefaultDispenseItemBehavior {
         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack1);
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) direction.getStepX(), (double) direction.getStepY(), (double) direction.getStepZ()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             serverLevel.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java b/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
index 626e9feb6a6e7a2cbc7c63e30ba4fb6b923e85c7..6ac9a0fc92eb9801bed3bc296988ee224afffa14 100644
--- a/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
@@ -25,7 +25,7 @@ public class ShearsDispenseItemBehavior extends OptionalDispenseItemBehavior {
         org.bukkit.block.Block bukkitBlock = org.bukkit.craftbukkit.block.CraftBlock.at(serverLevel, blockSource.pos());
         org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item); // Paper - ignore stack size on damageable items
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             serverLevel.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java b/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
index 5ab2c8333178335515e619b87ae420f948c83bd1..c98e3748ff467f75f0a0e5a429563feaf06105f3 100644
--- a/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
+++ b/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
@@ -27,7 +27,7 @@ public class ShulkerBoxDispenseBehavior extends OptionalDispenseItemBehavior {
             org.bukkit.craftbukkit.inventory.CraftItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.copyWithCount(1)); // Paper - single item in event
 
             org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockPos.getX(), blockPos.getY(), blockPos.getZ()));
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                 blockSource.level().getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index e8a0d231b7743a86af1b1f24fef310b69040f573..4cf8b5ea1eeef2fdc182d0d88983df8d440f26ab 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -173,58 +173,58 @@ import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
-    private static MinecraftServer SERVER; // Paper
-    public static final Logger LOGGER = LogUtils.getLogger();
+public abstract class MinecraftServer extends net.minecraft.util.thread.ReentrantBlockableEventLoop<net.minecraft.server.TickTask> implements net.minecraft.server.ServerInfo, net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter, net.minecraft.commands.CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
+    private static net.minecraft.server.MinecraftServer SERVER; // Paper
+    public static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger();
     public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
-    private static final long OVERLOADED_THRESHOLD_NANOS = 30L * TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
+    private static final long OVERLOADED_THRESHOLD_NANOS = 30L * net.minecraft.util.TimeUtil.NANOSECONDS_PER_SECOND / 20L; // CraftBukkit
     private static final int OVERLOADED_TICKS_THRESHOLD = 20;
-    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * TimeUtil.NANOSECONDS_PER_SECOND;
+    private static final long OVERLOADED_WARNING_INTERVAL_NANOS = 10L * net.minecraft.util.TimeUtil.NANOSECONDS_PER_SECOND;
     private static final int OVERLOADED_TICKS_WARNING_INTERVAL = 100;
-    private static final long STATUS_EXPIRE_TIME_NANOS = 5L * TimeUtil.NANOSECONDS_PER_SECOND;
-    private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * TimeUtil.NANOSECONDS_PER_MILLISECOND;
+    private static final long STATUS_EXPIRE_TIME_NANOS = 5L * net.minecraft.util.TimeUtil.NANOSECONDS_PER_SECOND;
+    private static final long PREPARE_LEVELS_DEFAULT_DELAY_NANOS = 10L * net.minecraft.util.TimeUtil.NANOSECONDS_PER_MILLISECOND;
     private static final int MAX_STATUS_PLAYER_SAMPLE = 12;
     private static final int SPAWN_POSITION_SEARCH_RADIUS = 5;
     private static final int AUTOSAVE_INTERVAL = 6000;
     private static final int MIMINUM_AUTOSAVE_TICKS = 100;
     private static final int MAX_TICK_LATENCY = 3;
     public static final int ABSOLUTE_MAX_WORLD_SIZE = 29999984;
-    public static final LevelSettings DEMO_SETTINGS = new LevelSettings(
-        "Demo World", GameType.SURVIVAL, false, Difficulty.NORMAL, false, new GameRules(FeatureFlags.DEFAULT_FLAGS), WorldDataConfiguration.DEFAULT
+    public static final net.minecraft.world.level.LevelSettings DEMO_SETTINGS = new net.minecraft.world.level.LevelSettings(
+        "Demo World", net.minecraft.world.level.GameType.SURVIVAL, false, net.minecraft.world.Difficulty.NORMAL, false, new net.minecraft.world.level.GameRules(net.minecraft.world.flag.FeatureFlags.DEFAULT_FLAGS), net.minecraft.world.level.WorldDataConfiguration.DEFAULT
     );
-    public static final GameProfile ANONYMOUS_PLAYER_PROFILE = new GameProfile(Util.NIL_UUID, "Anonymous Player");
-    public LevelStorageSource.LevelStorageAccess storageSource;
-    public final PlayerDataStorage playerDataStorage;
-    private final List<Runnable> tickables = Lists.newArrayList();
-    private MetricsRecorder metricsRecorder = InactiveMetricsRecorder.INSTANCE;
-    private Consumer<ProfileResults> onMetricsRecordingStopped = results -> this.stopRecordingMetrics();
-    private Consumer<Path> onMetricsRecordingFinished = path -> {};
+    public static final com.mojang.authlib.GameProfile ANONYMOUS_PLAYER_PROFILE = new com.mojang.authlib.GameProfile(net.minecraft.Util.NIL_UUID, "Anonymous Player");
+    public net.minecraft.world.level.storage.LevelStorageSource.LevelStorageAccess storageSource;
+    public final net.minecraft.world.level.storage.PlayerDataStorage playerDataStorage;
+    private final java.util.List<Runnable> tickables = com.google.common.collect.Lists.newArrayList();
+    private net.minecraft.util.profiling.metrics.profiling.MetricsRecorder metricsRecorder = net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder.INSTANCE;
+    private java.util.function.Consumer<net.minecraft.util.profiling.ProfileResults> onMetricsRecordingStopped = results -> this.stopRecordingMetrics();
+    private java.util.function.Consumer<java.nio.file.Path> onMetricsRecordingFinished = path -> {};
     private boolean willStartRecordingMetrics;
-    @Nullable
-    private MinecraftServer.TimeProfiler debugCommandProfiler;
+    @javax.annotation.Nullable
+    private net.minecraft.server.MinecraftServer.TimeProfiler debugCommandProfiler;
     private boolean debugCommandProfilerDelayStart;
-    private ServerConnectionListener connection;
-    public final ChunkProgressListenerFactory progressListenerFactory;
-    @Nullable
-    private ServerStatus status;
-    @Nullable
-    private ServerStatus.Favicon statusIcon;
-    private final RandomSource random = RandomSource.create();
-    public final DataFixer fixerUpper;
+    private net.minecraft.server.network.ServerConnectionListener connection;
+    public final net.minecraft.server.level.progress.ChunkProgressListenerFactory progressListenerFactory;
+    @javax.annotation.Nullable
+    private net.minecraft.network.protocol.status.ServerStatus status;
+    @javax.annotation.Nullable
+    private net.minecraft.network.protocol.status.ServerStatus.Favicon statusIcon;
+    private final net.minecraft.util.RandomSource random = net.minecraft.util.RandomSource.create();
+    public final com.mojang.datafixers.DataFixer fixerUpper;
     private String localIp;
     private int port = -1;
-    private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
-    private PlayerList playerList;
+    private final net.minecraft.core.LayeredRegistryAccess<net.minecraft.server.RegistryLayer> registries;
+    private java.util.Map<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> levels = com.google.common.collect.Maps.newLinkedHashMap();
+    private net.minecraft.server.players.PlayerList playerList;
     private volatile boolean running = true;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
     private boolean stopped;
     private int tickCount;
     private int ticksUntilAutosave = 6000;
-    protected final Proxy proxy;
+    protected final java.net.Proxy proxy;
     private boolean onlineMode;
     private boolean preventProxyConnections;
     private boolean pvp;
@@ -234,52 +234,52 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private final long[] tickTimesNanos = new long[100];
     private long aggregatedTickTimesNanos = 0L;
     // Paper start - Add tick times API and /mspt command
-    public final TickTimes tickTimes5s = new TickTimes(100);
-    public final TickTimes tickTimes10s = new TickTimes(200);
-    public final TickTimes tickTimes60s = new TickTimes(1200);
+    public final net.minecraft.server.MinecraftServer.TickTimes tickTimes5s = new net.minecraft.server.MinecraftServer.TickTimes(100);
+    public final net.minecraft.server.MinecraftServer.TickTimes tickTimes10s = new net.minecraft.server.MinecraftServer.TickTimes(200);
+    public final net.minecraft.server.MinecraftServer.TickTimes tickTimes60s = new net.minecraft.server.MinecraftServer.TickTimes(1200);
     // Paper end - Add tick times API and /mspt command
-    @Nullable
-    private KeyPair keyPair;
-    @Nullable
-    private GameProfile singleplayerProfile;
+    @javax.annotation.Nullable
+    private java.security.KeyPair keyPair;
+    @javax.annotation.Nullable
+    private com.mojang.authlib.GameProfile singleplayerProfile;
     private boolean isDemo;
     private volatile boolean isReady;
     private long lastOverloadWarningNanos;
-    protected final Services services;
+    protected final net.minecraft.server.Services services;
     private long lastServerStatus;
     public final Thread serverThread;
-    private long lastTickNanos = Util.getNanos();
-    private long taskExecutionStartNanos = Util.getNanos();
+    private long lastTickNanos = net.minecraft.Util.getNanos();
+    private long taskExecutionStartNanos = net.minecraft.Util.getNanos();
     private long idleTimeNanos;
-    private long nextTickTimeNanos = Util.getNanos();
+    private long nextTickTimeNanos = net.minecraft.Util.getNanos();
     private boolean waitingForNextTick = false;
     private long delayedTasksMaxNextTickTimeNanos;
     private boolean mayHaveDelayedTasks;
-    private final PackRepository packRepository;
-    private final ServerScoreboard scoreboard = new ServerScoreboard(this);
-    @Nullable
-    private CommandStorage commandStorage;
-    private final CustomBossEvents customBossEvents = new CustomBossEvents();
-    private final ServerFunctionManager functionManager;
+    private final net.minecraft.server.packs.repository.PackRepository packRepository;
+    private final net.minecraft.server.ServerScoreboard scoreboard = new net.minecraft.server.ServerScoreboard(this);
+    @javax.annotation.Nullable
+    private net.minecraft.world.level.storage.CommandStorage commandStorage;
+    private final net.minecraft.server.bossevents.CustomBossEvents customBossEvents = new net.minecraft.server.bossevents.CustomBossEvents();
+    private final net.minecraft.server.ServerFunctionManager functionManager;
     private boolean enforceWhitelist;
     private float smoothedTickTimeMillis;
-    public final Executor executor;
-    @Nullable
+    public final java.util.concurrent.Executor executor;
+    @javax.annotation.Nullable
     private String serverId;
-    public MinecraftServer.ReloadableResources resources;
-    private final StructureTemplateManager structureTemplateManager;
-    private final ServerTickRateManager tickRateManager;
-    protected WorldData worldData;
-    public PotionBrewing potionBrewing;
-    private FuelValues fuelValues;
+    public net.minecraft.server.MinecraftServer.ReloadableResources resources;
+    private final net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager structureTemplateManager;
+    private final net.minecraft.server.ServerTickRateManager tickRateManager;
+    protected net.minecraft.world.level.storage.WorldData worldData;
+    public net.minecraft.world.item.alchemy.PotionBrewing potionBrewing;
+    private net.minecraft.world.level.block.entity.FuelValues fuelValues;
     private int emptyTicks;
     private volatile boolean isSaving;
-    private static final AtomicReference<RuntimeException> fatalException = new AtomicReference<>();
-    private final SuppressedExceptionCollector suppressedExceptions = new SuppressedExceptionCollector();
-    private final DiscontinuousFrame tickFrame;
+    private static final java.util.concurrent.atomic.AtomicReference<RuntimeException> fatalException = new java.util.concurrent.atomic.AtomicReference<>();
+    private final net.minecraft.server.SuppressedExceptionCollector suppressedExceptions = new net.minecraft.server.SuppressedExceptionCollector();
+    private final com.mojang.jtracy.DiscontinuousFrame tickFrame;
 
     // CraftBukkit start
-    public final WorldLoader.DataLoadContext worldLoader;
+    public final net.minecraft.server.WorldLoader.DataLoadContext worldLoader;
     public org.bukkit.craftbukkit.CraftServer server;
     public joptsimple.OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
@@ -291,7 +291,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit end
     // Spigot start
     public static final int TPS = 20;
-    public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
+    public static final int TICK_TIME = 1000000000 / net.minecraft.server.MinecraftServer.TPS;
     private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
     @Deprecated(forRemoval = true) // Paper
     public final double[] recentTps = new double[3];
@@ -301,19 +301,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile Thread shutdownThread; // Paper - Improved watchdog support
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
-    private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
+    private final java.util.Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
     // SparklyPaper - skip EntityScheduler's executeTick checks if there isn't any tasks to be run (concurrent because plugins may schedule tasks async)
-    public final Set<net.minecraft.world.entity.Entity> entitiesWithScheduledTasks = java.util.concurrent.ConcurrentHashMap.newKeySet();
-
-    public static <S extends MinecraftServer> S spin(Function<Thread, S> threadFunction) {
+    public final java.util.Set<net.minecraft.world.entity.Entity> entitiesWithScheduledTasks = java.util.concurrent.ConcurrentHashMap.newKeySet();
+    public java.util.concurrent.Semaphore serverLevelTickingSemaphore = null; // SparklyPaper - parallel world ticking
+    public static <S extends net.minecraft.server.MinecraftServer> S spin(java.util.function.Function<Thread, S> threadFunction) {
         ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry.init(); // Paper - rewrite data converter system
-        AtomicReference<S> atomicReference = new AtomicReference<>();
-        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> atomicReference.get().runServer(), "Server thread");
+        java.util.concurrent.atomic.AtomicReference<S> atomicReference = new java.util.concurrent.atomic.AtomicReference<>();
+        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> atomicReference.get().runServer(), "Server thread"); // TO-DO: set thread affinity?
         thread.setUncaughtExceptionHandler((thread1, exception) -> LOGGER.error("Uncaught exception in server thread", exception));
         thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
         if (Runtime.getRuntime().availableProcessors() > 4) {
-            thread.setPriority(8);
+            thread.setPriority(9);
         }
 
         S minecraftServer = (S)threadFunction.apply(thread);
@@ -341,7 +341,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // give all worlds a fair chance at by targeting them all.
         // if we execute too many tasks, that's fine - we have logic to correctly handle overuse of allocated time.
         boolean executed = false;
-        for (final ServerLevel world : this.getAllLevels()) {
+        for (final net.minecraft.server.level.ServerLevel world : this.getAllLevels()) {
             long currTime = System.nanoTime();
             if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
                 continue;
@@ -396,50 +396,49 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public MinecraftServer(
         // CraftBukkit start
         joptsimple.OptionSet options,
-        WorldLoader.DataLoadContext worldLoader,
+        net.minecraft.server.WorldLoader.DataLoadContext worldLoader,
         // CraftBukkit end
         Thread serverThread,
-        LevelStorageSource.LevelStorageAccess storageSource,
-        PackRepository packRepository,
-        WorldStem worldStem,
-        Proxy proxy,
-        DataFixer fixerUpper,
-        Services services,
-        ChunkProgressListenerFactory progressListenerFactory
+        net.minecraft.world.level.storage.LevelStorageSource.LevelStorageAccess storageSource,
+        net.minecraft.server.packs.repository.PackRepository packRepository,
+        net.minecraft.server.WorldStem worldStem,
+        java.net.Proxy proxy,
+        com.mojang.datafixers.DataFixer fixerUpper,
+        net.minecraft.server.Services services,
+        net.minecraft.server.level.progress.ChunkProgressListenerFactory progressListenerFactory
     ) {
         super("Server");
         SERVER = this; // Paper - better singleton
         this.registries = worldStem.registries();
         this.worldData = worldStem.worldData();
-        if (false && !this.registries.compositeAccess().lookupOrThrow(Registries.LEVEL_STEM).containsKey(LevelStem.OVERWORLD)) { // CraftBukkit - initialised later
+        if (false && !this.registries.compositeAccess().lookupOrThrow(net.minecraft.core.registries.Registries.LEVEL_STEM).containsKey(net.minecraft.world.level.dimension.LevelStem.OVERWORLD)) { // CraftBukkit - initialised later
             throw new IllegalStateException("Missing Overworld dimension data");
         } else {
             this.proxy = proxy;
             this.packRepository = packRepository;
-            this.resources = new MinecraftServer.ReloadableResources(worldStem.resourceManager(), worldStem.dataPackResources());
+            this.resources = new net.minecraft.server.MinecraftServer.ReloadableResources(worldStem.resourceManager(), worldStem.dataPackResources());
             this.services = services;
             if (services.profileCache() != null) {
                 services.profileCache().setExecutor(this);
             }
-
             // this.connection = new ServerConnectionListener(this); // Spigot
-            this.tickRateManager = new ServerTickRateManager(this);
+            this.tickRateManager = new net.minecraft.server.ServerTickRateManager(this);
             this.progressListenerFactory = progressListenerFactory;
             this.storageSource = storageSource;
             this.playerDataStorage = storageSource.createPlayerStorage();
             this.fixerUpper = fixerUpper;
-            this.functionManager = new ServerFunctionManager(this, this.resources.managers.getFunctionLibrary());
-            HolderGetter<Block> holderGetter = this.registries
+            this.functionManager = new net.minecraft.server.ServerFunctionManager(this, this.resources.managers.getFunctionLibrary());
+            net.minecraft.core.HolderGetter<net.minecraft.world.level.block.Block> holderGetter = this.registries
                 .compositeAccess()
-                .lookupOrThrow(Registries.BLOCK)
+                .lookupOrThrow(net.minecraft.core.registries.Registries.BLOCK)
                 .filterFeatures(this.worldData.enabledFeatures());
-            this.structureTemplateManager = new StructureTemplateManager(worldStem.resourceManager(), storageSource, fixerUpper, holderGetter);
+            this.structureTemplateManager = new net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager(worldStem.resourceManager(), storageSource, fixerUpper, holderGetter);
             this.serverThread = serverThread;
-            this.executor = Util.backgroundExecutor();
-            this.potionBrewing = PotionBrewing.bootstrap(this.worldData.enabledFeatures());
+            this.executor = net.minecraft.Util.backgroundExecutor();
+            this.potionBrewing = net.minecraft.world.item.alchemy.PotionBrewing.bootstrap(this.worldData.enabledFeatures());
             this.resources.managers.getRecipeManager().finalizeRecipeLoading(this.worldData.enabledFeatures());
-            this.fuelValues = FuelValues.vanillaBurnTimes(this.registries.compositeAccess(), this.worldData.enabledFeatures());
-            this.tickFrame = TracyClient.createDiscontinuousFrame("Server Tick");
+            this.fuelValues = net.minecraft.world.level.block.entity.FuelValues.vanillaBurnTimes(this.registries.compositeAccess(), this.worldData.enabledFeatures());
+            this.tickFrame = com.mojang.jtracy.TracyClient.createDiscontinuousFrame("Server Tick");
         }
         // CraftBukkit start
         this.options = options;
@@ -475,18 +474,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.paperConfigurations = services.paperConfigurations(); // Paper - add paper configuration files
     }
 
-    private void readScoreboard(DimensionDataStorage dataStorage) {
+    private void readScoreboard(net.minecraft.world.level.storage.DimensionDataStorage dataStorage) {
         dataStorage.computeIfAbsent(this.getScoreboard().dataFactory(), "scoreboard");
     }
 
-    protected abstract boolean initServer() throws IOException;
+    protected abstract boolean initServer() throws java.io.IOException;
 
     protected void loadLevel(String levelId) { // CraftBukkit
-        if (!JvmProfiler.INSTANCE.isRunning()) {
+        if (!net.minecraft.util.profiling.jfr.JvmProfiler.INSTANCE.isRunning()) {
         }
 
         boolean flag = false;
-        ProfiledDuration profiledDuration = JvmProfiler.INSTANCE.onWorldLoadedStarted();
+        net.minecraft.util.profiling.jfr.callback.ProfiledDuration profiledDuration = net.minecraft.util.profiling.jfr.JvmProfiler.INSTANCE.onWorldLoadedStarted();
         this.loadWorld0(levelId); // CraftBukkit
         if (profiledDuration != null) {
             profiledDuration.finish(true);
@@ -494,7 +493,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         if (flag) {
             try {
-                JvmProfiler.INSTANCE.stop();
+                net.minecraft.util.profiling.jfr.JvmProfiler.INSTANCE.stop();
             } catch (Throwable var5) {
                 LOGGER.warn("Failed to stop JFR profiling", var5);
             }
@@ -507,71 +506,71 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit start
     private void loadWorld0(String levelId) {
         // Mostly modelled off of net.minecraft.server.Main
-        LevelStorageSource.LevelStorageAccess levelStorageAccess = this.storageSource;
-        RegistryAccess.Frozen registryAccess = this.registries.compositeAccess();
-        Registry<LevelStem> levelStemRegistry = registryAccess.lookupOrThrow(Registries.LEVEL_STEM);
-        for (LevelStem levelStem : levelStemRegistry) {
-            ResourceKey<LevelStem> levelStemKey = levelStemRegistry.getResourceKey(levelStem).get();
-            ServerLevel serverLevel;
+        net.minecraft.world.level.storage.LevelStorageSource.LevelStorageAccess levelStorageAccess = this.storageSource;
+        net.minecraft.core.RegistryAccess.Frozen registryAccess = this.registries.compositeAccess();
+        net.minecraft.core.Registry<net.minecraft.world.level.dimension.LevelStem> levelStemRegistry = registryAccess.lookupOrThrow(net.minecraft.core.registries.Registries.LEVEL_STEM);
+        for (net.minecraft.world.level.dimension.LevelStem levelStem : levelStemRegistry) {
+            net.minecraft.resources.ResourceKey<net.minecraft.world.level.dimension.LevelStem> levelStemKey = levelStemRegistry.getResourceKey(levelStem).get();
+            net.minecraft.server.level.ServerLevel serverLevel;
             int dimension = 0;
 
-            if (levelStemKey == LevelStem.NETHER) {
+            if (levelStemKey == net.minecraft.world.level.dimension.LevelStem.NETHER) {
                 if (this.server.getAllowNether()) {
                     dimension = -1;
                 } else {
                     continue;
                 }
-            } else if (levelStemKey == LevelStem.END) {
+            } else if (levelStemKey == net.minecraft.world.level.dimension.LevelStem.END) {
                 if (this.server.getAllowEnd()) {
                     dimension = 1;
                 } else {
                     continue;
                 }
-            } else if (levelStemKey != LevelStem.OVERWORLD) {
+            } else if (levelStemKey != net.minecraft.world.level.dimension.LevelStem.OVERWORLD) {
                 dimension = -999;
             }
 
             // Migration of old CB world folders...
-            String worldType = (dimension == -999) ? levelStemKey.location().getNamespace() + "_" + levelStemKey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase(Locale.ROOT);
-            String name = (levelStemKey == LevelStem.OVERWORLD) ? levelId : levelId + "_" + worldType;
+            String worldType = (dimension == -999) ? levelStemKey.location().getNamespace() + "_" + levelStemKey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase(java.util.Locale.ROOT);
+            String name = (levelStemKey == net.minecraft.world.level.dimension.LevelStem.OVERWORLD) ? levelId : levelId + "_" + worldType;
             if (dimension != 0) {
-                java.io.File newWorld = LevelStorageSource.getStorageFolder(new java.io.File(name).toPath(), levelStemKey).toFile();
-                java.io.File oldWorld = LevelStorageSource.getStorageFolder(new java.io.File(levelId).toPath(), levelStemKey).toFile();
+                java.io.File newWorld = net.minecraft.world.level.storage.LevelStorageSource.getStorageFolder(new java.io.File(name).toPath(), levelStemKey).toFile();
+                java.io.File oldWorld = net.minecraft.world.level.storage.LevelStorageSource.getStorageFolder(new java.io.File(levelId).toPath(), levelStemKey).toFile();
                 java.io.File oldLevelDat = new java.io.File(new java.io.File(levelId), "level.dat"); // The data folders exist on first run as they are created in the PersistentCollection constructor above, but the level.dat won't
 
                 if (!newWorld.isDirectory() && oldWorld.isDirectory() && oldLevelDat.isFile()) {
-                    MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
-                    MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
-                    MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
-                    MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
 
                     if (newWorld.exists()) {
-                        MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
-                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                        net.minecraft.server.MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
+                        net.minecraft.server.MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
                     } else if (newWorld.getParentFile().mkdirs()) {
                         if (oldWorld.renameTo(newWorld)) {
-                            MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+                            net.minecraft.server.MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
                             // Migrate world data too.
                             try {
                                 com.google.common.io.Files.copy(oldLevelDat, new java.io.File(new java.io.File(name), "level.dat"));
                                 org.apache.commons.io.FileUtils.copyDirectory(new java.io.File(new java.io.File(levelId), "data"), new java.io.File(new java.io.File(name), "data"));
-                            } catch (IOException exception) {
-                                MinecraftServer.LOGGER.warn("Unable to migrate world data.");
+                            } catch (java.io.IOException exception) {
+                                net.minecraft.server.MinecraftServer.LOGGER.warn("Unable to migrate world data.");
                             }
-                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
+                            net.minecraft.server.MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
                         } else {
-                            MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
-                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                            net.minecraft.server.MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            net.minecraft.server.MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
                         }
                     } else {
-                        MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
-                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                        net.minecraft.server.MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
+                        net.minecraft.server.MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
                     }
                 }
 
                 try {
-                    levelStorageAccess = LevelStorageSource.createDefault(this.server.getWorldContainer().toPath()).validateAndCreateAccess(name, levelStemKey);
-                } catch (IOException | net.minecraft.world.level.validation.ContentValidationException ex) {
+                    levelStorageAccess = net.minecraft.world.level.storage.LevelStorageSource.createDefault(this.server.getWorldContainer().toPath()).validateAndCreateAccess(name, levelStemKey);
+                } catch (java.io.IOException | net.minecraft.world.level.validation.ContentValidationException ex) {
                     throw new RuntimeException(ex);
                 }
             }
@@ -582,17 +581,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 try {
                     dataTag = levelStorageAccess.getDataTag();
                     summary = levelStorageAccess.getSummary(dataTag);
-                } catch (net.minecraft.nbt.NbtException | net.minecraft.nbt.ReportedNbtException | IOException e) {
-                    LevelStorageSource.LevelDirectory levelDirectory = levelStorageAccess.getLevelDirectory();
-                    MinecraftServer.LOGGER.warn("Failed to load world data from {}", levelDirectory.dataFile(), e);
-                    MinecraftServer.LOGGER.info("Attempting to use fallback");
+                } catch (net.minecraft.nbt.NbtException | net.minecraft.nbt.ReportedNbtException | java.io.IOException e) {
+                    net.minecraft.world.level.storage.LevelStorageSource.LevelDirectory levelDirectory = levelStorageAccess.getLevelDirectory();
+                    net.minecraft.server.MinecraftServer.LOGGER.warn("Failed to load world data from {}", levelDirectory.dataFile(), e);
+                    net.minecraft.server.MinecraftServer.LOGGER.info("Attempting to use fallback");
 
                     try {
                         dataTag = levelStorageAccess.getDataTagFallback();
                         summary = levelStorageAccess.getSummary(dataTag);
-                    } catch (net.minecraft.nbt.NbtException | net.minecraft.nbt.ReportedNbtException | IOException e1) {
-                        MinecraftServer.LOGGER.error("Failed to load world data from {}", levelDirectory.oldDataFile(), e1);
-                        MinecraftServer.LOGGER.error(
+                    } catch (net.minecraft.nbt.NbtException | net.minecraft.nbt.ReportedNbtException | java.io.IOException e1) {
+                        net.minecraft.server.MinecraftServer.LOGGER.error("Failed to load world data from {}", levelDirectory.oldDataFile(), e1);
+                        net.minecraft.server.MinecraftServer.LOGGER.error(
                             "Failed to load world data from {} and {}. World files may be corrupted. Shutting down.",
                             levelDirectory.dataFile(),
                             levelDirectory.oldDataFile()
@@ -604,12 +603,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
 
                 if (summary.requiresManualConversion()) {
-                    MinecraftServer.LOGGER.info("This world must be opened in an older version (like 1.6.4) to be safely converted");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("This world must be opened in an older version (like 1.6.4) to be safely converted");
                     return;
                 }
 
                 if (!summary.isCompatible()) {
-                    MinecraftServer.LOGGER.info("This world was created by an incompatible version.");
+                    net.minecraft.server.MinecraftServer.LOGGER.info("This world was created by an incompatible version.");
                     return;
                 }
             } else {
@@ -620,30 +619,30 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             org.bukkit.generator.BiomeProvider biomeProvider = this.server.getBiomeProvider(name);
 
             net.minecraft.world.level.storage.PrimaryLevelData primaryLevelData;
-            WorldLoader.DataLoadContext context = this.worldLoader;
-            Registry<LevelStem> contextLevelStemRegistry = context.datapackDimensions().lookupOrThrow(Registries.LEVEL_STEM);
+            net.minecraft.server.WorldLoader.DataLoadContext context = this.worldLoader;
+            net.minecraft.core.Registry<net.minecraft.world.level.dimension.LevelStem> contextLevelStemRegistry = context.datapackDimensions().lookupOrThrow(net.minecraft.core.registries.Registries.LEVEL_STEM);
             if (dataTag != null) {
-                net.minecraft.world.level.storage.LevelDataAndDimensions levelDataAndDimensions = LevelStorageSource.getLevelDataAndDimensions(
+                net.minecraft.world.level.storage.LevelDataAndDimensions levelDataAndDimensions = net.minecraft.world.level.storage.LevelStorageSource.getLevelDataAndDimensions(
                     dataTag, context.dataConfiguration(), contextLevelStemRegistry, context.datapackWorldgen()
                 );
                 primaryLevelData = (net.minecraft.world.level.storage.PrimaryLevelData) levelDataAndDimensions.worldData();
             } else {
-                LevelSettings levelSettings;
-                WorldOptions worldOptions;
+                net.minecraft.world.level.LevelSettings levelSettings;
+                net.minecraft.world.level.levelgen.WorldOptions worldOptions;
                 net.minecraft.world.level.levelgen.WorldDimensions worldDimensions;
                 if (this.isDemo()) {
-                    levelSettings = MinecraftServer.DEMO_SETTINGS;
-                    worldOptions = WorldOptions.DEMO_OPTIONS;
+                    levelSettings = net.minecraft.server.MinecraftServer.DEMO_SETTINGS;
+                    worldOptions = net.minecraft.world.level.levelgen.WorldOptions.DEMO_OPTIONS;
                     worldDimensions = net.minecraft.world.level.levelgen.presets.WorldPresets.createNormalWorldDimensions(context.datapackWorldgen());
                 } else {
                     net.minecraft.server.dedicated.DedicatedServerProperties properties = ((net.minecraft.server.dedicated.DedicatedServer) this).getProperties();
-                    levelSettings = new LevelSettings(
+                    levelSettings = new net.minecraft.world.level.LevelSettings(
                         properties.levelName,
                         properties.gamemode,
                         properties.hardcore,
                         properties.difficulty,
                         false,
-                        new GameRules(context.dataConfiguration().enabledFeatures()),
+                        new net.minecraft.world.level.GameRules(context.dataConfiguration().enabledFeatures()),
                         context.dataConfiguration()
                     );
                     worldOptions = this.options.has("bonusChest") ? properties.worldOptions.withBonusChest(true) : properties.worldOptions; // CraftBukkit
@@ -658,51 +657,51 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             primaryLevelData.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
             if (this.options.has("forceUpgrade")) {
-                net.minecraft.server.Main.forceUpgrade(levelStorageAccess, net.minecraft.util.datafix.DataFixers.getDataFixer(), this.options.has("eraseCache"), () -> true, registryAccess, this.options.has("recreateRegionFiles"));
+                Main.forceUpgrade(levelStorageAccess, net.minecraft.util.datafix.DataFixers.getDataFixer(), this.options.has("eraseCache"), () -> true, registryAccess, this.options.has("recreateRegionFiles"));
             }
 
             // Now modelled off the createLevels method
             net.minecraft.world.level.storage.PrimaryLevelData serverLevelData = primaryLevelData;
             boolean isDebugWorld = primaryLevelData.isDebugWorld();
-            WorldOptions worldOptions = primaryLevelData.worldGenOptions();
+            net.minecraft.world.level.levelgen.WorldOptions worldOptions = primaryLevelData.worldGenOptions();
             long seed = worldOptions.seed();
-            long l = BiomeManager.obfuscateSeed(seed);
-            List<CustomSpawner> list = ImmutableList.of(
-                new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(serverLevelData)
+            long l = net.minecraft.world.level.biome.BiomeManager.obfuscateSeed(seed);
+            java.util.List<net.minecraft.world.level.CustomSpawner> list = com.google.common.collect.ImmutableList.of(
+                new net.minecraft.world.level.levelgen.PhantomSpawner(), new net.minecraft.world.level.levelgen.PatrolSpawner(), new net.minecraft.world.entity.npc.CatSpawner(), new net.minecraft.world.entity.ai.village.VillageSiege(), new net.minecraft.world.entity.npc.WanderingTraderSpawner(serverLevelData)
             );
-            LevelStem customStem = levelStemRegistry.getValue(levelStemKey);
+            net.minecraft.world.level.dimension.LevelStem customStem = levelStemRegistry.getValue(levelStemKey);
 
             org.bukkit.generator.WorldInfo worldInfo = new org.bukkit.craftbukkit.generator.CraftWorldInfo(serverLevelData, levelStorageAccess, org.bukkit.World.Environment.getEnvironment(dimension), customStem.type().value(), customStem.generator(), this.registryAccess()); // Paper - Expose vanilla BiomeProvider from WorldInfo
             if (biomeProvider == null && chunkGenerator != null) {
                 biomeProvider = chunkGenerator.getDefaultBiomeProvider(worldInfo);
             }
 
-            ResourceKey<Level> dimensionKey = ResourceKey.create(Registries.DIMENSION, levelStemKey.location());
+            net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level> dimensionKey = net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.DIMENSION, levelStemKey.location());
 
-            if (levelStemKey == LevelStem.OVERWORLD) {
+            if (levelStemKey == net.minecraft.world.level.dimension.LevelStem.OVERWORLD) {
                 this.worldData = primaryLevelData;
                 this.worldData.setGameType(((net.minecraft.server.dedicated.DedicatedServer) this).getProperties().gamemode); // From DedicatedServer.init
 
-                ChunkProgressListener listener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS));
+                net.minecraft.server.level.progress.ChunkProgressListener listener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(net.minecraft.world.level.GameRules.RULE_SPAWN_CHUNK_RADIUS));
 
-                serverLevel = new ServerLevel(
+                serverLevel = new net.minecraft.server.level.ServerLevel(
                     this, this.executor, levelStorageAccess, serverLevelData, dimensionKey, customStem, listener, isDebugWorld, l, list, true, null,
                     org.bukkit.World.Environment.getEnvironment(dimension), chunkGenerator, biomeProvider
                 );
-                DimensionDataStorage dataStorage = serverLevel.getDataStorage();
+                net.minecraft.world.level.storage.DimensionDataStorage dataStorage = serverLevel.getDataStorage();
                 this.readScoreboard(dataStorage);
-                this.commandStorage = new CommandStorage(dataStorage);
+                this.commandStorage = new net.minecraft.world.level.storage.CommandStorage(dataStorage);
                 this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, serverLevel.getScoreboard());
             } else {
-                ChunkProgressListener listener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS));
+                net.minecraft.server.level.progress.ChunkProgressListener listener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(net.minecraft.world.level.GameRules.RULE_SPAWN_CHUNK_RADIUS));
                 // Paper start - option to use the dimension_type to check if spawners should be added. I imagine mojang will add some datapack-y way of managing this in the future.
-                final List<CustomSpawner> spawners;
-                if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.useDimensionTypeForCustomSpawners && this.registryAccess().lookupOrThrow(Registries.DIMENSION_TYPE).getResourceKey(customStem.type().value()).orElseThrow() == net.minecraft.world.level.dimension.BuiltinDimensionTypes.OVERWORLD) {
+                final java.util.List<net.minecraft.world.level.CustomSpawner> spawners;
+                if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.useDimensionTypeForCustomSpawners && this.registryAccess().lookupOrThrow(net.minecraft.core.registries.Registries.DIMENSION_TYPE).getResourceKey(customStem.type().value()).orElseThrow() == net.minecraft.world.level.dimension.BuiltinDimensionTypes.OVERWORLD) {
                     spawners = list;
                 } else {
-                    spawners = Collections.emptyList();
+                    spawners = java.util.Collections.emptyList();
                 }
-                serverLevel = new ServerLevel(
+                serverLevel = new net.minecraft.server.level.ServerLevel(
                     this, this.executor, levelStorageAccess, serverLevelData, dimensionKey, customStem, listener, isDebugWorld, l, spawners, true, this.overworld().getRandomSequences(),
                     org.bukkit.World.Environment.getEnvironment(dimension), chunkGenerator, biomeProvider
                 );
@@ -722,14 +721,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
         this.forceDifficulty();
-        for (ServerLevel serverLevel : this.getAllLevels()) {
+        for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
             this.prepareLevels(serverLevel.getChunkSource().chunkMap.progressListener, serverLevel);
             // Paper - rewrite chunk system
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(serverLevel.getWorld()));
         }
 
         // Paper start - Configurable player collision; Handle collideRule team for player collision toggle
-        final ServerScoreboard scoreboard = this.getScoreboard();
+        final net.minecraft.server.ServerScoreboard scoreboard = this.getScoreboard();
         final java.util.Collection<String> toRemove = scoreboard.getPlayerTeams().stream().filter(team -> team.getName().startsWith("collideRule_")).map(net.minecraft.world.scores.PlayerTeam::getName).collect(java.util.stream.Collectors.toList());
         for (String teamName : toRemove) {
             scoreboard.removePlayerTeam(scoreboard.getPlayerTeam(teamName)); // Clean up after ourselves
@@ -753,13 +752,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.connection.acceptConnections();
     }
 
-    public void initWorld(ServerLevel serverLevel, ServerLevelData serverLevelData, WorldData saveData, WorldOptions worldOptions) {
+    public void initWorld(net.minecraft.server.level.ServerLevel serverLevel, net.minecraft.world.level.storage.ServerLevelData serverLevelData, net.minecraft.world.level.storage.WorldData saveData, net.minecraft.world.level.levelgen.WorldOptions worldOptions) {
         boolean isDebugWorld = saveData.isDebugWorld();
         if (serverLevel.generator != null) {
             serverLevel.getWorld().getPopulators().addAll(serverLevel.generator.getDefaultPopulators(serverLevel.getWorld()));
         }
         // CraftBukkit start
-        WorldBorder worldborder = serverLevel.getWorldBorder();
+        net.minecraft.world.level.border.WorldBorder worldborder = serverLevel.getWorldBorder();
         worldborder.applySettings(serverLevelData.getWorldBorder()); // CraftBukkit - move up so that WorldBorder is set during WorldInitEvent
         this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(serverLevel.getWorld())); // CraftBukkit - SPIGOT-5569: Call WorldInitEvent before any chunks are generated
 
@@ -771,14 +770,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     this.setupDebugLevel(this.worldData);
                 }
             } catch (Throwable var23) {
-                CrashReport crashReport = CrashReport.forThrowable(var23, "Exception initializing level");
+                net.minecraft.CrashReport crashReport = net.minecraft.CrashReport.forThrowable(var23, "Exception initializing level");
 
                 try {
                     serverLevel.fillReportDetails(crashReport);
                 } catch (Throwable var22) {
                 }
 
-                throw new ReportedException(crashReport);
+                throw new net.minecraft.ReportedException(crashReport);
             }
 
             serverLevelData.setInitialized(true);
@@ -786,11 +785,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
     // CraftBukkit end
 
-    private static void setInitialSpawn(ServerLevel level, ServerLevelData levelData, boolean generateBonusChest, boolean debug) {
+    private static void setInitialSpawn(net.minecraft.server.level.ServerLevel level, net.minecraft.world.level.storage.ServerLevelData levelData, boolean generateBonusChest, boolean debug) {
         if (debug) {
-            levelData.setSpawn(BlockPos.ZERO.above(80), 0.0F);
+            levelData.setSpawn(net.minecraft.core.BlockPos.ZERO.above(80), 0.0F);
         } else {
-            ServerChunkCache chunkSource = level.getChunkSource();
+            net.minecraft.server.level.ServerChunkCache chunkSource = level.getChunkSource();
             // CraftBukkit start
             if (level.generator != null) {
                 java.util.Random rand = new java.util.Random(level.getSeed());
@@ -800,17 +799,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     if (spawn.getWorld() != level.getWorld()) {
                         throw new IllegalStateException("Cannot set spawn point for " + levelData.getLevelName() + " to be in another world (" + spawn.getWorld().getName() + ")");
                     } else {
-                        levelData.setSpawn(new BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()), spawn.getYaw());
+                        levelData.setSpawn(new net.minecraft.core.BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()), spawn.getYaw());
                         return;
                     }
                 }
             }
             // CraftBukkit end
-            ChunkPos chunkPos = new ChunkPos(chunkSource.randomState().sampler().findSpawnPosition()); // Paper - Only attempt to find spawn position if there isn't a fixed spawn position set
+            net.minecraft.world.level.ChunkPos chunkPos = new net.minecraft.world.level.ChunkPos(chunkSource.randomState().sampler().findSpawnPosition()); // Paper - Only attempt to find spawn position if there isn't a fixed spawn position set
             int spawnHeight = chunkSource.getGenerator().getSpawnHeight(level);
             if (spawnHeight < level.getMinY()) {
-                BlockPos worldPosition = chunkPos.getWorldPosition();
-                spawnHeight = level.getHeight(Heightmap.Types.WORLD_SURFACE, worldPosition.getX() + 8, worldPosition.getZ() + 8);
+                net.minecraft.core.BlockPos worldPosition = chunkPos.getWorldPosition();
+                spawnHeight = level.getHeight(net.minecraft.world.level.levelgen.Heightmap.Types.WORLD_SURFACE, worldPosition.getX() + 8, worldPosition.getZ() + 8);
             }
 
             levelData.setSpawn(chunkPos.getWorldPosition().offset(8, spawnHeight, 8), 0.0F);
@@ -819,9 +818,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             int i2 = 0;
             int i3 = -1;
 
-            for (int i4 = 0; i4 < Mth.square(11); i4++) {
+            for (int i4 = 0; i4 < net.minecraft.util.Mth.square(11); i4++) {
                 if (i >= -5 && i <= 5 && i1 >= -5 && i1 <= 5) {
-                    BlockPos spawnPosInChunk = PlayerRespawnLogic.getSpawnPosInChunk(level, new ChunkPos(chunkPos.x + i, chunkPos.z + i1));
+                    net.minecraft.core.BlockPos spawnPosInChunk = net.minecraft.server.level.PlayerRespawnLogic.getSpawnPosInChunk(level, new net.minecraft.world.level.ChunkPos(chunkPos.x + i, chunkPos.z + i1));
                     if (spawnPosInChunk != null) {
                         levelData.setSpawn(spawnPosInChunk, 0.0F);
                         break;
@@ -840,36 +839,36 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             if (generateBonusChest) {
                 level.registryAccess()
-                    .lookup(Registries.CONFIGURED_FEATURE)
-                    .flatMap(registry -> registry.get(MiscOverworldFeatures.BONUS_CHEST))
+                    .lookup(net.minecraft.core.registries.Registries.CONFIGURED_FEATURE)
+                    .flatMap(registry -> registry.get(net.minecraft.data.worldgen.features.MiscOverworldFeatures.BONUS_CHEST))
                     .ifPresent(holder -> holder.value().place(level, chunkSource.getGenerator(), level.random, levelData.getSpawnPos()));
             }
         }
     }
 
-    private void setupDebugLevel(WorldData worldData) {
-        worldData.setDifficulty(Difficulty.PEACEFUL);
+    private void setupDebugLevel(net.minecraft.world.level.storage.WorldData worldData) {
+        worldData.setDifficulty(net.minecraft.world.Difficulty.PEACEFUL);
         worldData.setDifficultyLocked(true);
-        ServerLevelData serverLevelData = worldData.overworldData();
+        net.minecraft.world.level.storage.ServerLevelData serverLevelData = worldData.overworldData();
         serverLevelData.setRaining(false);
         serverLevelData.setThundering(false);
         serverLevelData.setClearWeatherTime(1000000000);
         serverLevelData.setDayTime(6000L);
-        serverLevelData.setGameType(GameType.SPECTATOR);
+        serverLevelData.setGameType(net.minecraft.world.level.GameType.SPECTATOR);
     }
 
     // CraftBukkit start
-    public void prepareLevels(ChunkProgressListener listener, ServerLevel serverLevel) {
+    public void prepareLevels(net.minecraft.server.level.progress.ChunkProgressListener listener, net.minecraft.server.level.ServerLevel serverLevel) {
         this.forceTicks = true;
         // CraftBukkit end
         LOGGER.info("Preparing start region for dimension {}", serverLevel.dimension().location());
-        BlockPos sharedSpawnPos = serverLevel.getSharedSpawnPos();
-        listener.updateSpawnPos(new ChunkPos(sharedSpawnPos));
-        ServerChunkCache chunkSource = serverLevel.getChunkSource();
-        this.nextTickTimeNanos = Util.getNanos();
+        net.minecraft.core.BlockPos sharedSpawnPos = serverLevel.getSharedSpawnPos();
+        listener.updateSpawnPos(new net.minecraft.world.level.ChunkPos(sharedSpawnPos));
+        net.minecraft.server.level.ServerChunkCache chunkSource = serverLevel.getChunkSource();
+        this.nextTickTimeNanos = net.minecraft.Util.getNanos();
         serverLevel.setDefaultSpawnPos(sharedSpawnPos, serverLevel.getSharedSpawnAngle());
-        int _int = serverLevel.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS); // CraftBukkit - per-world
-        int i = _int > 0 ? Mth.square(ChunkProgressListener.calculateDiameter(_int)) : 0;
+        int _int = serverLevel.getGameRules().getInt(net.minecraft.world.level.GameRules.RULE_SPAWN_CHUNK_RADIUS); // CraftBukkit - per-world
+        int i = _int > 0 ? net.minecraft.util.Mth.square(net.minecraft.server.level.progress.ChunkProgressListener.calculateDiameter(_int)) : 0;
 
         while (chunkSource.getTickingGenerated() < i) {
             // CraftBukkit start
@@ -881,15 +880,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.executeModerately();
 
         if (true) {
-            ServerLevel serverLevel1 = serverLevel;
+            net.minecraft.server.level.ServerLevel serverLevel1 = serverLevel;
             // CraftBukkit end
-            ForcedChunksSavedData forcedChunksSavedData = serverLevel1.getDataStorage().get(ForcedChunksSavedData.factory(), "chunks");
+            net.minecraft.world.level.ForcedChunksSavedData forcedChunksSavedData = serverLevel1.getDataStorage().get(net.minecraft.world.level.ForcedChunksSavedData.factory(), "chunks");
             if (forcedChunksSavedData != null) {
-                LongIterator longIterator = forcedChunksSavedData.getChunks().iterator();
+                it.unimi.dsi.fastutil.longs.LongIterator longIterator = forcedChunksSavedData.getChunks().iterator();
 
                 while (longIterator.hasNext()) {
                     long l = longIterator.nextLong();
-                    ChunkPos chunkPos = new ChunkPos(l);
+                    net.minecraft.world.level.ChunkPos chunkPos = new net.minecraft.world.level.ChunkPos(l);
                     serverLevel1.getChunkSource().updateChunkForced(chunkPos, true);
                 }
             }
@@ -902,13 +901,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         listener.stop();
         // CraftBukkit start
         // this.updateMobSpawningFlags();
-        serverLevel.setSpawnSettings(serverLevel.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
+        serverLevel.setSpawnSettings(serverLevel.serverLevelData.getDifficulty() != net.minecraft.world.Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
 
         this.forceTicks = false;
         // CraftBukkit end
     }
 
-    public GameType getDefaultGameType() {
+    public net.minecraft.world.level.GameType getDefaultGameType() {
         return this.worldData.getGameType();
     }
 
@@ -930,7 +929,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper end - add close param
         boolean flag = false;
 
-        for (ServerLevel serverLevel : this.getAllLevels()) {
+        for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
             if (!suppressLog) {
                 LOGGER.info("Saving chunks for level '{}'/{}", serverLevel, serverLevel.dimension().location());
             }
@@ -948,7 +947,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
          */
         // CraftBukkit end
         if (flush) {
-            for (ServerLevel serverLevel2 : this.getAllLevels()) {
+            for (net.minecraft.server.level.ServerLevel serverLevel2 : this.getAllLevels()) {
                 LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", serverLevel2.getChunkSource().chunkMap.getStorageName());
             }
 
@@ -1002,7 +1001,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         LOGGER.info("Stopping server");
-        Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+        net.minecraft.commands.Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+
         // CraftBukkit start
         if (this.server != null) {
             this.server.spark.disable(); // Paper - spark
@@ -1022,16 +1022,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         LOGGER.info("Saving worlds");
 
-        for (ServerLevel serverLevel : this.getAllLevels()) {
+        for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
             if (serverLevel != null) {
                 serverLevel.noSave = false;
             }
         }
 
         while (false && this.levels.values().stream().anyMatch(level -> level.getChunkSource().chunkMap.hasWork())) { // Paper - rewrite chunk system
-            this.nextTickTimeNanos = Util.getNanos() + TimeUtil.NANOSECONDS_PER_MILLISECOND;
+            this.nextTickTimeNanos = net.minecraft.Util.getNanos() + net.minecraft.util.TimeUtil.NANOSECONDS_PER_MILLISECOND;
 
-            for (ServerLevel serverLevelx : this.getAllLevels()) {
+            for (net.minecraft.server.level.ServerLevel serverLevelx : this.getAllLevels()) {
                 serverLevelx.getChunkSource().removeTicketsOnClosing();
                 serverLevelx.getChunkSource().tick(() -> true, false);
             }
@@ -1046,14 +1046,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         try {
             this.storageSource.close();
-        } catch (IOException var4) {
+        } catch (java.io.IOException var4) {
             LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), var4);
         }
         // Spigot start
         io.papermc.paper.util.MCUtil.ASYNC_EXECUTOR.shutdown(); // Paper
         try {
             io.papermc.paper.util.MCUtil.ASYNC_EXECUTOR.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
-        } catch (java.lang.InterruptedException ignored) {} // Paper
+        } catch (InterruptedException ignored) {} // Paper
         if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
             LOGGER.info("Saving usercache.json");
             this.getProfileCache().save(false); // Paper - Perf: Async GameProfileCache saving
@@ -1061,14 +1061,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Spigot end
         // Paper start - rewrite chunk system
         LOGGER.info("Waiting for I/O tasks to complete...");
-        ca.spottedleaf.moonrise.patches.chunk_system.io.MoonriseRegionFileIO.flush((MinecraftServer)(Object)this);
+        ca.spottedleaf.moonrise.patches.chunk_system.io.MoonriseRegionFileIO.flush((net.minecraft.server.MinecraftServer)(Object)this);
         LOGGER.info("All I/O tasks to complete");
         if ((Object)this instanceof net.minecraft.server.dedicated.DedicatedServer) {
             ca.spottedleaf.moonrise.common.util.MoonriseCommon.haltExecutors();
         }
         // Paper end - rewrite chunk system
+
         // Paper start - Improved watchdog support - move final shutdown items here
-        Util.shutdownExecutors();
+        net.minecraft.Util.shutdownExecutors();
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (final Exception ignored) {
@@ -1114,9 +1115,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
     private long lastTick = 0;
     private long catchupTime = 0;
-    public final RollingAverage tps1 = new RollingAverage(60);
-    public final RollingAverage tps5 = new RollingAverage(60 * 5);
-    public final RollingAverage tps15 = new RollingAverage(60 * 15);
+    public final net.minecraft.server.MinecraftServer.RollingAverage tps1 = new net.minecraft.server.MinecraftServer.RollingAverage(60);
+    public final net.minecraft.server.MinecraftServer.RollingAverage tps5 = new net.minecraft.server.MinecraftServer.RollingAverage(60 * 5);
+    public final net.minecraft.server.MinecraftServer.RollingAverage tps15 = new net.minecraft.server.MinecraftServer.RollingAverage(60 * 15);
 
     public static class RollingAverage {
         private final int size;
@@ -1166,7 +1167,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 throw new IllegalStateException("Failed to initialize server");
             }
 
-            this.nextTickTimeNanos = Util.getNanos();
+            this.nextTickTimeNanos = net.minecraft.Util.getNanos();
             this.statusIcon = this.loadStatusIcon().orElse(null);
             this.status = this.buildServerStatus();
 
@@ -1184,9 +1185,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             org.spigotmc.WatchdogThread.tick();
             // Paper end
             org.spigotmc.WatchdogThread.hasStarted = true; // Paper
-            Arrays.fill(this.recentTps, 20);
+            java.util.Arrays.fill(this.recentTps, 20);
             // Paper start - further improve server tick loop
-            long tickSection = Util.getNanos();
+            long tickSection = net.minecraft.Util.getNanos();
             long currentTime;
             // Paper end - further improve server tick loop
             // Paper start - Add onboarding message for initial server start
@@ -1203,24 +1204,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 long l;
                 if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
                     l = 0L;
-                    this.nextTickTimeNanos = Util.getNanos();
+                    this.nextTickTimeNanos = net.minecraft.Util.getNanos();
                     this.lastOverloadWarningNanos = this.nextTickTimeNanos;
                 } else {
                     l = this.tickRateManager.nanosecondsPerTick();
-                    long l1 = Util.getNanos() - this.nextTickTimeNanos;
+                    long l1 = net.minecraft.Util.getNanos() - this.nextTickTimeNanos;
                     if (l1 > OVERLOADED_THRESHOLD_NANOS + 20L * l
                         && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= OVERLOADED_WARNING_INTERVAL_NANOS + 100L * l) {
                         long l2 = l1 / l;
                         if (this.server.getWarnOnOverload()) // CraftBukkit
-                        LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", l1 / TimeUtil.NANOSECONDS_PER_MILLISECOND, l2);
+                        LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", l1 / net.minecraft.util.TimeUtil.NANOSECONDS_PER_MILLISECOND, l2);
                         this.nextTickTimeNanos += l2 * l;
                         this.lastOverloadWarningNanos = this.nextTickTimeNanos;
                     }
                 }
                 // Spigot start
                 // Paper start - further improve server tick loop
-                currentTime = Util.getNanos();
-                if (++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
+                currentTime = net.minecraft.Util.getNanos();
+                if (++net.minecraft.server.MinecraftServer.currentTick % net.minecraft.server.MinecraftServer.SAMPLE_INTERVAL == 0) {
                     final long diff = currentTime - tickSection;
                     final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
                     tps1.add(currentTps, diff);
@@ -1239,15 +1240,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 boolean flag = l == 0L;
                 if (this.debugCommandProfilerDelayStart) {
                     this.debugCommandProfilerDelayStart = false;
-                    this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
+                    this.debugCommandProfiler = new net.minecraft.server.MinecraftServer.TimeProfiler(net.minecraft.Util.getNanos(), this.tickCount);
                 }
 
                 //MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit // Paper - don't overwrite current tick time
                 lastTick = currentTime;
                 this.nextTickTimeNanos += l;
 
-                try (Profiler.Scope scope = Profiler.use(this.createProfiler())) {
-                    ProfilerFiller profilerFiller = Profiler.get();
+                try (net.minecraft.util.profiling.Profiler.Scope scope = net.minecraft.util.profiling.Profiler.use(this.createProfiler())) {
+                    net.minecraft.util.profiling.ProfilerFiller profilerFiller = net.minecraft.util.profiling.Profiler.get();
                     profilerFiller.push("tick");
                     this.tickFrame.start();
                     this.tickServer(flag ? () -> false : this::haveTime);
@@ -1261,7 +1262,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     this.tickFrame.end();
                     profilerFiller.popPush("nextTickWait");
                     this.mayHaveDelayedTasks = true;
-                    this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + l, this.nextTickTimeNanos);
+                    this.delayedTasksMaxNextTickTimeNanos = Math.max(net.minecraft.Util.getNanos() + l, this.nextTickTimeNanos);
                     this.startMeasuringTaskExecutionTime();
                     this.waitUntilNextTick();
                     this.finishMeasuringTaskExecutionTime();
@@ -1276,14 +1277,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
 
                 this.isReady = true;
-                JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
+                net.minecraft.util.profiling.jfr.JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
             }
         } catch (Throwable var69) {
             LOGGER.error("Encountered an unexpected exception", var69);
-            CrashReport crashReport = constructOrExtractCrashReport(var69);
+            net.minecraft.CrashReport crashReport = constructOrExtractCrashReport(var69);
             this.fillSystemReport(crashReport.getSystemReport());
-            Path path = this.getServerDirectory().resolve("crash-reports").resolve("crash-" + Util.getFilenameFormattedDateTime() + "-server.txt");
-            if (crashReport.saveToFile(path, ReportType.CRASH)) {
+            java.nio.file.Path path = this.getServerDirectory().resolve("crash-reports").resolve("crash-" + net.minecraft.Util.getFilenameFormattedDateTime() + "-server.txt");
+            if (crashReport.saveToFile(path, net.minecraft.ReportType.CRASH)) {
                 LOGGER.error("This crash report has been saved to: {}", path.toAbsolutePath());
             } else {
                 LOGGER.error("We were unable to save this crash report to disk.");
@@ -1307,7 +1308,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private void logFullTickTime() {
-        long nanos = Util.getNanos();
+        long nanos = net.minecraft.Util.getNanos();
         if (this.isTickTimeLoggingEnabled()) {
             this.getTickTimeLogger().logSample(nanos - this.lastTickNanos);
         }
@@ -1317,36 +1318,36 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private void startMeasuringTaskExecutionTime() {
         if (this.isTickTimeLoggingEnabled()) {
-            this.taskExecutionStartNanos = Util.getNanos();
+            this.taskExecutionStartNanos = net.minecraft.Util.getNanos();
             this.idleTimeNanos = 0L;
         }
     }
 
     private void finishMeasuringTaskExecutionTime() {
         if (this.isTickTimeLoggingEnabled()) {
-            SampleLogger tickTimeLogger = this.getTickTimeLogger();
-            tickTimeLogger.logPartialSample(Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
-            tickTimeLogger.logPartialSample(this.idleTimeNanos, TpsDebugDimensions.IDLE.ordinal());
+            net.minecraft.util.debugchart.SampleLogger tickTimeLogger = this.getTickTimeLogger();
+            tickTimeLogger.logPartialSample(net.minecraft.Util.getNanos() - this.taskExecutionStartNanos - this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.SCHEDULED_TASKS.ordinal());
+            tickTimeLogger.logPartialSample(this.idleTimeNanos, net.minecraft.util.debugchart.TpsDebugDimensions.IDLE.ordinal());
         }
     }
 
-    private static CrashReport constructOrExtractCrashReport(Throwable cause) {
-        ReportedException reportedException = null;
+    private static net.minecraft.CrashReport constructOrExtractCrashReport(Throwable cause) {
+        net.minecraft.ReportedException reportedException = null;
 
         for (Throwable throwable = cause; throwable != null; throwable = throwable.getCause()) {
-            if (throwable instanceof ReportedException reportedException1) {
+            if (throwable instanceof net.minecraft.ReportedException reportedException1) {
                 reportedException = reportedException1;
             }
         }
 
-        CrashReport report;
+        net.minecraft.CrashReport report;
         if (reportedException != null) {
             report = reportedException.getReport();
             if (reportedException != cause) {
                 report.addCategory("Wrapped in").setDetailError("Wrapping exception", cause);
             }
         } else {
-            report = new CrashReport("Exception in server tick loop", cause);
+            report = new net.minecraft.CrashReport("Exception in server tick loop", cause);
         }
 
         return report;
@@ -1354,7 +1355,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private boolean haveTime() {
         // CraftBukkit start
-        return this.forceTicks || this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+        return this.forceTicks || this.runningTask() || net.minecraft.Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
     }
 
     private void executeModerately() {
@@ -1373,11 +1374,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public static void setFatalException(RuntimeException fatalException) {
-        MinecraftServer.fatalException.compareAndSet(null, fatalException);
+        net.minecraft.server.MinecraftServer.fatalException.compareAndSet(null, fatalException);
     }
 
     @Override
-    public void managedBlock(BooleanSupplier isDone) {
+    public void managedBlock(java.util.function.BooleanSupplier isDone) {
         super.managedBlock(() -> throwIfFatalException() && isDone.getAsBoolean());
     }
 
@@ -1395,27 +1396,27 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     @Override
     public void waitForTasks() {
         boolean isTickTimeLoggingEnabled = this.isTickTimeLoggingEnabled();
-        long l = isTickTimeLoggingEnabled ? Util.getNanos() : 0L;
-        long l1 = this.waitingForNextTick ? this.nextTickTimeNanos - Util.getNanos() : 100000L;
-        LockSupport.parkNanos("waiting for tasks", l1);
+        long l = isTickTimeLoggingEnabled ? net.minecraft.Util.getNanos() : 0L;
+        long l1 = this.waitingForNextTick ? this.nextTickTimeNanos - net.minecraft.Util.getNanos() : 100000L;
+        java.util.concurrent.locks.LockSupport.parkNanos("waiting for tasks", l1);
         if (isTickTimeLoggingEnabled) {
-            this.idleTimeNanos = this.idleTimeNanos + (Util.getNanos() - l);
+            this.idleTimeNanos = this.idleTimeNanos + (net.minecraft.Util.getNanos() - l);
         }
     }
 
     @Override
-    public TickTask wrapRunnable(Runnable runnable) {
+    public net.minecraft.server.TickTask wrapRunnable(Runnable runnable) {
         // Paper start - anything that does try to post to main during watchdog crash, run on watchdog
         if (this.hasStopped && Thread.currentThread().equals(shutdownThread)) {
             runnable.run();
             runnable = () -> {};
         }
         // Paper end
-        return new TickTask(this.tickCount, runnable);
+        return new net.minecraft.server.TickTask(this.tickCount, runnable);
     }
 
     @Override
-    protected boolean shouldRun(TickTask runnable) {
+    protected boolean shouldRun(net.minecraft.server.TickTask runnable) {
         return runnable.getTick() + 3 < this.tickCount || this.haveTime();
     }
 
@@ -1433,7 +1434,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } else {
             boolean ret = false; // Paper - force execution of all worlds, do not just bias the first
             if (this.tickRateManager.isSprinting() || this.haveTime()) {
-                for (ServerLevel serverLevel : this.getAllLevels()) {
+                for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
                     if (serverLevel.getChunkSource().pollTask()) {
                         ret = true; // Paper - force execution of all worlds, do not just bias the first
                     }
@@ -1445,39 +1446,39 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     @Override
-    public void doRunTask(TickTask task) {
-        Profiler.get().incrementCounter("runTask");
+    public void doRunTask(net.minecraft.server.TickTask task) {
+        net.minecraft.util.profiling.Profiler.get().incrementCounter("runTask");
         super.doRunTask(task);
     }
 
-    private Optional<ServerStatus.Favicon> loadStatusIcon() {
-        Optional<Path> optional = Optional.of(this.getFile("server-icon.png"))
-            .filter(path -> Files.isRegularFile(path))
-            .or(() -> this.storageSource.getIconFile().filter(path -> Files.isRegularFile(path)));
+    private java.util.Optional<net.minecraft.network.protocol.status.ServerStatus.Favicon> loadStatusIcon() {
+        java.util.Optional<java.nio.file.Path> optional = java.util.Optional.of(this.getFile("server-icon.png"))
+            .filter(path -> java.nio.file.Files.isRegularFile(path))
+            .or(() -> this.storageSource.getIconFile().filter(path -> java.nio.file.Files.isRegularFile(path)));
         return optional.flatMap(path -> {
             try {
-                BufferedImage bufferedImage = ImageIO.read(path.toFile());
-                Preconditions.checkState(bufferedImage.getWidth() == 64, "Must be 64 pixels wide");
-                Preconditions.checkState(bufferedImage.getHeight() == 64, "Must be 64 pixels high");
-                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-                ImageIO.write(bufferedImage, "PNG", byteArrayOutputStream);
-                return Optional.of(new ServerStatus.Favicon(byteArrayOutputStream.toByteArray()));
+                java.awt.image.BufferedImage bufferedImage = javax.imageio.ImageIO.read(path.toFile());
+                com.google.common.base.Preconditions.checkState(bufferedImage.getWidth() == 64, "Must be 64 pixels wide");
+                com.google.common.base.Preconditions.checkState(bufferedImage.getHeight() == 64, "Must be 64 pixels high");
+                java.io.ByteArrayOutputStream byteArrayOutputStream = new java.io.ByteArrayOutputStream();
+                javax.imageio.ImageIO.write(bufferedImage, "PNG", byteArrayOutputStream);
+                return java.util.Optional.of(new net.minecraft.network.protocol.status.ServerStatus.Favicon(byteArrayOutputStream.toByteArray()));
             } catch (Exception var3) {
                 LOGGER.error("Couldn't load server icon", (Throwable)var3);
-                return Optional.empty();
+                return java.util.Optional.empty();
             }
         });
     }
 
-    public Optional<Path> getWorldScreenshotFile() {
+    public java.util.Optional<java.nio.file.Path> getWorldScreenshotFile() {
         return this.storageSource.getIconFile();
     }
 
-    public Path getServerDirectory() {
-        return Path.of("");
+    public java.nio.file.Path getServerDirectory() {
+        return java.nio.file.Path.of("");
     }
 
-    public void onServerCrash(CrashReport report) {
+    public void onServerCrash(net.minecraft.CrashReport report) {
     }
 
     public void onServerExit() {
@@ -1487,9 +1488,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
-    public void tickServer(BooleanSupplier hasTimeLeft) {
+    public void tickServer(java.util.function.BooleanSupplier hasTimeLeft) {
         org.spigotmc.WatchdogThread.tick(); // Spigot
-        long nanos = Util.getNanos();
+        long nanos = net.minecraft.Util.getNanos();
         int i = this.pauseWhileEmptySeconds() * 20;
         this.removeDisabledPluginsBlockingSleep(); // Paper - API to allow/disallow tick sleeping
         if (i > 0) {
@@ -1512,7 +1513,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 while ((task = this.processQueue.poll()) != null) {
                     task.run();
                 }
-                for (final ServerLevel level : this.levels.values()) {
+                for (final net.minecraft.server.level.ServerLevel level : this.levels.values()) {
                     // process unloads
                     level.getChunkSource().tick(() -> true, false);
                 }
@@ -1536,7 +1537,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.ticksUntilAutosave--;
         // Paper start - Incremental chunk and player saving
-        final ProfilerFiller profiler = Profiler.get();
+        final net.minecraft.util.profiling.ProfilerFiller profiler = net.minecraft.util.profiling.Profiler.get();
         int playerSaveInterval = io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.rate;
         if (playerSaveInterval < 0) {
             playerSaveInterval = autosavePeriod;
@@ -1548,7 +1549,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             if (playerSaveInterval > 0) {
                 this.playerList.saveAll(playerSaveInterval);
             }
-            for (final ServerLevel level : this.getAllLevels()) {
+            for (final net.minecraft.server.level.ServerLevel level : this.getAllLevels()) {
                 if (level.paperConfig().chunks.autoSaveInterval.value() > 0) {
                     level.saveIncrementally(fullSave);
                 }
@@ -1559,7 +1560,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         profiler.pop();
         // Paper end - Incremental chunk and player saving
 
-        ProfilerFiller profilerFiller = Profiler.get();
+        net.minecraft.util.profiling.ProfilerFiller profilerFiller = net.minecraft.util.profiling.Profiler.get();
         this.runAllTasks(); // Paper - move runAllTasks() into full server tick (previously for timings)
         this.server.spark.executeMainThreadTasks(); // Paper - spark
         // Paper start - Server Tick Events
@@ -1569,12 +1570,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper end - Server Tick Events
         this.server.spark.tickEnd(((double)(endTime - lastTick) / 1000000D)); // Paper - spark
         profilerFiller.push("tallying");
-        long l = Util.getNanos() - nanos;
+        long l = net.minecraft.Util.getNanos() - nanos;
         int i1 = this.tickCount % 100;
         this.aggregatedTickTimesNanos = this.aggregatedTickTimesNanos - this.tickTimesNanos[i1];
         this.aggregatedTickTimesNanos += l;
         this.tickTimesNanos[i1] = l;
-        this.smoothedTickTimeMillis = this.smoothedTickTimeMillis * 0.8F + (float)l / (float)TimeUtil.NANOSECONDS_PER_MILLISECOND * 0.19999999F;
+        this.smoothedTickTimeMillis = this.smoothedTickTimeMillis * 0.8F + (float)l / (float) net.minecraft.util.TimeUtil.NANOSECONDS_PER_MILLISECOND * 0.19999999F;
         // Paper start - Add tick times API and /mspt command
         this.tickTimes5s.add(this.tickCount, l);
         this.tickTimes10s.add(this.tickCount, l);
@@ -1587,7 +1588,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private void autoSave() {
         this.ticksUntilAutosave = this.autosavePeriod; // CraftBukkit
         LOGGER.debug("Autosave started");
-        ProfilerFiller profilerFiller = Profiler.get();
+        net.minecraft.util.profiling.ProfilerFiller profilerFiller = net.minecraft.util.profiling.Profiler.get();
         profilerFiller.push("save");
         this.saveEverything(true, false, false);
         profilerFiller.pop();
@@ -1596,7 +1597,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private void logTickMethodTime(long startTime) {
         if (this.isTickTimeLoggingEnabled()) {
-            this.getTickTimeLogger().logPartialSample(Util.getNanos() - startTime, TpsDebugDimensions.TICK_SERVER_METHOD.ordinal());
+            this.getTickTimeLogger().logPartialSample(net.minecraft.Util.getNanos() - startTime, net.minecraft.util.debugchart.TpsDebugDimensions.TICK_SERVER_METHOD.ordinal());
         }
     }
 
@@ -1604,7 +1605,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         float f;
         if (this.tickRateManager.isSprinting()) {
             long l = this.getAverageTickTimeNanos() + 1L;
-            f = (float)TimeUtil.NANOSECONDS_PER_SECOND / (float)l;
+            f = (float) net.minecraft.util.TimeUtil.NANOSECONDS_PER_SECOND / (float)l;
         } else {
             f = this.tickRateManager.tickrate();
         }
@@ -1620,43 +1621,43 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    protected abstract SampleLogger getTickTimeLogger();
+    protected abstract net.minecraft.util.debugchart.SampleLogger getTickTimeLogger();
 
     public abstract boolean isTickTimeLoggingEnabled();
 
-    private ServerStatus buildServerStatus() {
-        ServerStatus.Players players = this.buildPlayerStatus();
-        return new ServerStatus(
+    private net.minecraft.network.protocol.status.ServerStatus buildServerStatus() {
+        net.minecraft.network.protocol.status.ServerStatus.Players players = this.buildPlayerStatus();
+        return new net.minecraft.network.protocol.status.ServerStatus(
             io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), // Paper - Adventure
-            Optional.of(players),
-            Optional.of(ServerStatus.Version.current()),
-            Optional.ofNullable(this.statusIcon),
+            java.util.Optional.of(players),
+            java.util.Optional.of(net.minecraft.network.protocol.status.ServerStatus.Version.current()),
+            java.util.Optional.ofNullable(this.statusIcon),
             this.enforceSecureProfile()
         );
     }
 
-    private ServerStatus.Players buildPlayerStatus() {
-        List<ServerPlayer> players = this.playerList.getPlayers();
+    private net.minecraft.network.protocol.status.ServerStatus.Players buildPlayerStatus() {
+        java.util.List<net.minecraft.server.level.ServerPlayer> players = this.playerList.getPlayers();
         int maxPlayers = this.getMaxPlayers();
         if (this.hidesOnlinePlayers()) {
-            return new ServerStatus.Players(maxPlayers, players.size(), List.of());
+            return new net.minecraft.network.protocol.status.ServerStatus.Players(maxPlayers, players.size(), java.util.List.of());
         } else {
             int min = Math.min(players.size(), org.spigotmc.SpigotConfig.playerSample); // Paper - PaperServerListPingEvent
-            ObjectArrayList<GameProfile> list = new ObjectArrayList<>(min);
-            int randomInt = Mth.nextInt(this.random, 0, players.size() - min);
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<com.mojang.authlib.GameProfile> list = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(min);
+            int randomInt = net.minecraft.util.Mth.nextInt(this.random, 0, players.size() - min);
 
             for (int i = 0; i < min; i++) {
-                ServerPlayer serverPlayer = players.get(randomInt + i);
+                net.minecraft.server.level.ServerPlayer serverPlayer = players.get(randomInt + i);
                 list.add(serverPlayer.allowsListing() ? serverPlayer.getGameProfile() : ANONYMOUS_PLAYER_PROFILE);
             }
 
-            Util.shuffle(list, this.random);
-            return new ServerStatus.Players(maxPlayers, players.size(), list);
+            net.minecraft.Util.shuffle(list, this.random);
+            return new net.minecraft.network.protocol.status.ServerStatus.Players(maxPlayers, players.size(), list);
         }
     }
 
-    protected void tickChildren(BooleanSupplier hasTimeLeft) {
-        ProfilerFiller profilerFiller = Profiler.get();
+    protected void tickChildren(java.util.function.BooleanSupplier hasTimeLeft) {
+        net.minecraft.util.profiling.ProfilerFiller profilerFiller = net.minecraft.util.profiling.Profiler.get();
         this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
@@ -1700,62 +1701,99 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
-            final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+        for (final net.minecraft.server.level.ServerLevel level : this.getAllLevels()) {
+            final boolean doDaylight = level.getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
-            final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
-            for (Player entityhuman : level.players()) {
-                if (!(entityhuman instanceof ServerPlayer) || (tickCount + entityhuman.getId()) % 20 != 0) {
+            final net.minecraft.network.protocol.game.ClientboundSetTimePacket worldPacket = new net.minecraft.network.protocol.game.ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+            for (net.minecraft.world.entity.player.Player entityhuman : level.players()) {
+                if (!(entityhuman instanceof net.minecraft.server.level.ServerPlayer) || (tickCount + entityhuman.getId()) % 20 != 0) {
                     continue;
                 }
-                ServerPlayer entityplayer = (ServerPlayer) entityhuman;
+                net.minecraft.server.level.ServerPlayer entityplayer = (net.minecraft.server.level.ServerPlayer) entityhuman;
                 long playerTime = entityplayer.getPlayerTime();
                 boolean relativeTime = entityplayer.relativeTime;
-                ClientboundSetTimePacket packet = ((relativeTime || !doDaylight) && playerTime == dayTime) ? worldPacket :
-                    new ClientboundSetTimePacket(worldTime, playerTime, relativeTime && doDaylight);
+                net.minecraft.network.protocol.game.ClientboundSetTimePacket packet = ((relativeTime || !doDaylight) && playerTime == dayTime) ? worldPacket :
+                    new net.minecraft.network.protocol.game.ClientboundSetTimePacket(worldTime, playerTime, relativeTime && doDaylight);
                 entityplayer.connection.send(packet); // Add support for per player time
                 // Paper end - Perf: Optimize time updates
             }
         }
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
-        for (ServerLevel serverLevel : this.getAllLevels()) {
-            serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            serverLevel.updateLagCompensationTick(); // Paper - lag compensation
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
-            profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().location());
-            /* Drop global time updates
-            if (this.tickCount % 20 == 0) {
-                profilerFiller.push("timeSync");
-                this.synchronizeTime(serverLevel);
-                profilerFiller.pop();
-            }
-            // CraftBukkit end */
+        // SparklyPaper start - parallel world ticking
+        java.util.ArrayDeque<java.util.concurrent.Future<ServerLevel>> tasks = new java.util.ArrayDeque<>();
+        try {
+            // Aincrad - Map each level to an asynchronous ticking task (a CompletableFuture).
+            java.util.List<java.util.concurrent.CompletableFuture<Void>> futures = new java.util.ArrayList<>();
+            for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
+                serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
+                serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
+                serverLevel.updateLagCompensationTick(); // Paper - lag compensation
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+                profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().location());
+        /* Drop global time updates
+        if (this.tickCount % 20 == 0) {
+            profilerFiller.push("timeSync");
+            this.synchronizeTime(serverLevel);
+            profilerFiller.pop();
+        }
+        // CraftBukkit end */
+                profilerFiller.push("tick");
 
-            profilerFiller.push("tick");
+                if (!serverLevel.tickExecutor.isShutdown()) { // Aincrad - ensure executor is active
+                    serverLevelTickingSemaphore.acquire();
+                    tasks.add(
+                        serverLevel.tickExecutor.submit(() -> {
+                            try {
+                                ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread currentThread = (ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread) Thread.currentThread();
+                                currentThread.currentlyTickingServerLevel = serverLevel;
+
+                                long i = Util.getNanos(); // SparklyPaper - track world's MSPT
+                                serverLevel.tick(hasTimeLeft);
+                                // SparklyPaper start - track world's MSPT
+                                long j = Util.getNanos() - i;
+
+                                // These are from the "tickServer" function
+                                serverLevel.tickTimes5s.add(this.tickCount, j);
+                                serverLevel.tickTimes10s.add(this.tickCount, j);
+                                serverLevel.tickTimes60s.add(this.tickCount, j);
+                                // SparklyPaper end
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+
+                                serverLevel.fillReportDetails(crashreport);
+                                throw new ReportedException(crashreport);
+                            } finally {
+                                serverLevelTickingSemaphore.release();
+                            }
+                        }, serverLevel)
+                    );
+                } else { // Aincrad - fallback to ticking synchronously when executor is shutdown
+                    LOGGER.warn("Synchronous ticking world {} as the executor is shutdown", serverLevel.dimension().location());
+                    serverLevel.tick(hasTimeLeft);
+                }
 
-            try {
-                serverLevel.tick(hasTimeLeft);
-            } catch (Throwable var7) {
-                CrashReport crashReport = CrashReport.forThrowable(var7, "Exception ticking world");
-                serverLevel.fillReportDetails(crashReport);
-                throw new ReportedException(crashReport);
+                profilerFiller.pop(); // Pop "tick" scope
+                profilerFiller.pop(); // Pop "levels" scope
+                serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
 
-            profilerFiller.pop();
-            profilerFiller.pop();
-            serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
+            while (!tasks.isEmpty()) {
+                tasks.pop().get();
+            }
+        } catch (java.lang.InterruptedException | java.util.concurrent.ExecutionException e) {
+            throw new RuntimeException(e); // Propagate exception
         }
+        // SparklyPaper end
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
         profilerFiller.popPush("connection");
         this.tickConnection();
         profilerFiller.popPush("players");
         this.playerList.tick();
-        if (SharedConstants.IS_RUNNING_IN_IDE && this.tickRateManager.runsNormally()) {
-            GameTestTicker.SINGLETON.tick();
+        if (net.minecraft.SharedConstants.IS_RUNNING_IN_IDE && this.tickRateManager.runsNormally()) {
+            net.minecraft.gametest.framework.GameTestTicker.SINGLETON.tick();
         }
 
         profilerFiller.popPush("server gui refresh");
@@ -1766,7 +1804,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         profilerFiller.popPush("send chunks");
 
-        for (ServerPlayer serverPlayer : this.playerList.getPlayers()) {
+        for (net.minecraft.server.level.ServerPlayer serverPlayer : this.playerList.getPlayers()) {
             serverPlayer.connection.chunkSender.sendNextChunks(serverPlayer);
             serverPlayer.connection.resumeFlushing();
         }
@@ -1778,26 +1816,26 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.getConnection().tick();
     }
 
-    private void synchronizeTime(ServerLevel level) {
+    private void synchronizeTime(net.minecraft.server.level.ServerLevel level) {
         this.playerList
             .broadcastAll(
-                new ClientboundSetTimePacket(level.getGameTime(), level.getDayTime(), level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)),
+                new net.minecraft.network.protocol.game.ClientboundSetTimePacket(level.getGameTime(), level.getDayTime(), level.getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_DAYLIGHT)),
                 level.dimension()
             );
     }
 
     public void forceTimeSynchronization() {
-        ProfilerFiller profilerFiller = Profiler.get();
+        net.minecraft.util.profiling.ProfilerFiller profilerFiller = net.minecraft.util.profiling.Profiler.get();
         profilerFiller.push("timeSync");
 
-        for (ServerLevel serverLevel : this.getAllLevels()) {
+        for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
             this.synchronizeTime(serverLevel);
         }
 
         profilerFiller.pop();
     }
 
-    public boolean isLevelEnabled(Level level) {
+    public boolean isLevelEnabled(net.minecraft.world.level.Level level) {
         return true;
     }
 
@@ -1813,46 +1851,47 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return !this.serverThread.isAlive();
     }
 
-    public Path getFile(String path) {
+    public java.nio.file.Path getFile(String path) {
         return this.getServerDirectory().resolve(path);
     }
 
-    public final ServerLevel overworld() {
-        return this.levels.get(Level.OVERWORLD);
+    public final net.minecraft.server.level.ServerLevel overworld() {
+        return this.levels.get(net.minecraft.world.level.Level.OVERWORLD);
     }
 
-    @Nullable
-    public ServerLevel getLevel(ResourceKey<Level> dimension) {
+    @javax.annotation.Nullable
+    public net.minecraft.server.level.ServerLevel getLevel(net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level> dimension) {
         return this.levels.get(dimension);
     }
 
     // CraftBukkit start
-    public void addLevel(ServerLevel level) {
-        Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
-        Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
+    public void addLevel(net.minecraft.server.level.ServerLevel level) {
+        java.util.Map<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> oldLevels = this.levels;
+        java.util.Map<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> newLevels = com.google.common.collect.Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
-        this.levels = Collections.unmodifiableMap(newLevels);
+        this.levels = java.util.Collections.unmodifiableMap(newLevels);
     }
 
-    public void removeLevel(ServerLevel level) {
-        Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
-        Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
+    public void removeLevel(net.minecraft.server.level.ServerLevel level) {
+        java.util.Map<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> oldLevels = this.levels;
+        java.util.Map<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> newLevels = com.google.common.collect.Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
-        this.levels = Collections.unmodifiableMap(newLevels);
+        level.tickExecutor.shutdown(); // SparklyPaper - parallel world ticking (We remove it in here instead of ServerLevel.close() because ServerLevel.close() is never called!)
+        this.levels = java.util.Collections.unmodifiableMap(newLevels);
     }
     // CraftBukkit end
 
-    public Set<ResourceKey<Level>> levelKeys() {
+    public java.util.Set<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>> levelKeys() {
         return this.levels.keySet();
     }
 
-    public Iterable<ServerLevel> getAllLevels() {
+    public Iterable<net.minecraft.server.level.ServerLevel> getAllLevels() {
         return this.levels.values();
     }
 
     @Override
     public String getServerVersion() {
-        return SharedConstants.getCurrentVersion().getName();
+        return net.minecraft.SharedConstants.getCurrentVersion().getName();
     }
 
     @Override
@@ -1869,12 +1908,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.playerList.getPlayerNamesArray();
     }
 
-    @DontObfuscate
+    @net.minecraft.obfuscate.DontObfuscate
     public String getServerModName() {
         return io.papermc.paper.ServerBuildInfo.buildInfo().brandName(); // Paper
     }
 
-    public SystemReport fillSystemReport(SystemReport systemReport) {
+    public net.minecraft.SystemReport fillSystemReport(net.minecraft.SystemReport systemReport) {
         systemReport.setDetail("Server Running", () -> Boolean.toString(this.running));
         if (this.playerList != null) {
             systemReport.setDetail(
@@ -1882,11 +1921,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             );
         }
 
-        systemReport.setDetail("Active Data Packs", () -> PackRepository.displayPackList(this.packRepository.getSelectedPacks()));
-        systemReport.setDetail("Available Data Packs", () -> PackRepository.displayPackList(this.packRepository.getAvailablePacks()));
+        systemReport.setDetail("Active Data Packs", () -> net.minecraft.server.packs.repository.PackRepository.displayPackList(this.packRepository.getSelectedPacks()));
+        systemReport.setDetail("Available Data Packs", () -> net.minecraft.server.packs.repository.PackRepository.displayPackList(this.packRepository.getAvailablePacks()));
         systemReport.setDetail(
             "Enabled Feature Flags",
-            () -> FeatureFlags.REGISTRY.toNames(this.worldData.enabledFeatures()).stream().map(ResourceLocation::toString).collect(Collectors.joining(", "))
+            () -> net.minecraft.world.flag.FeatureFlags.REGISTRY.toNames(this.worldData.enabledFeatures()).stream().map(net.minecraft.resources.ResourceLocation::toString).collect(java.util.stream.Collectors.joining(", "))
         );
         systemReport.setDetail("World Generation", () -> this.worldData.worldGenSettingsLifecycle().toString());
         systemReport.setDetail("World Seed", () -> String.valueOf(this.worldData.worldGenOptions().seed()));
@@ -1898,18 +1937,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.fillServerSystemReport(systemReport);
     }
 
-    public abstract SystemReport fillServerSystemReport(SystemReport report);
+    public abstract net.minecraft.SystemReport fillServerSystemReport(net.minecraft.SystemReport report);
 
-    public ModCheck getModdedStatus() {
-        return ModCheck.identify("vanilla", this::getServerModName, "Server", MinecraftServer.class);
+    public net.minecraft.util.ModCheck getModdedStatus() {
+        return net.minecraft.util.ModCheck.identify("vanilla", this::getServerModName, "Server", net.minecraft.server.MinecraftServer.class);
     }
 
     @Override
-    public void sendSystemMessage(Component component) {
+    public void sendSystemMessage(net.minecraft.network.chat.Component component) {
         LOGGER.info(io.papermc.paper.adventure.PaperAdventure.ANSI_SERIALIZER.serialize(io.papermc.paper.adventure.PaperAdventure.asAdventure(component))); // Paper - Log message with colors
     }
 
-    public KeyPair getKeyPair() {
+    public java.security.KeyPair getKeyPair() {
         return this.keyPair;
     }
 
@@ -1921,12 +1960,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.port = port;
     }
 
-    @Nullable
-    public GameProfile getSingleplayerProfile() {
+    @javax.annotation.Nullable
+    public com.mojang.authlib.GameProfile getSingleplayerProfile() {
         return this.singleplayerProfile;
     }
 
-    public void setSingleplayerProfile(@Nullable GameProfile singleplayerProfile) {
+    public void setSingleplayerProfile(@javax.annotation.Nullable com.mojang.authlib.GameProfile singleplayerProfile) {
         this.singleplayerProfile = singleplayerProfile;
     }
 
@@ -1938,18 +1977,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         LOGGER.info("Generating keypair");
 
         try {
-            this.keyPair = Crypt.generateKeyPair();
-        } catch (CryptException var2) {
+            this.keyPair = net.minecraft.util.Crypt.generateKeyPair();
+        } catch (net.minecraft.util.CryptException var2) {
             throw new IllegalStateException("Failed to generate key pair", var2);
         }
     }
 
     // Paper start - per level difficulty
-    public void setDifficulty(ServerLevel level, Difficulty difficulty, boolean forceUpdate) {
+    public void setDifficulty(net.minecraft.server.level.ServerLevel level, net.minecraft.world.Difficulty difficulty, boolean forceUpdate) {
         net.minecraft.world.level.storage.PrimaryLevelData worldData = (net.minecraft.world.level.storage.PrimaryLevelData) level.serverLevelData;
         if (forceUpdate || !worldData.isDifficultyLocked()) {
-            worldData.setDifficulty(worldData.isHardcore() ? Difficulty.HARD : difficulty);
-            level.setSpawnSettings(worldData.getDifficulty() != Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters);
+            worldData.setDifficulty(worldData.isHardcore() ? net.minecraft.world.Difficulty.HARD : difficulty);
+            level.setSpawnSettings(worldData.getDifficulty() != net.minecraft.world.Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters);
             // this.getPlayerList().getPlayers().forEach(this::sendDifficultyUpdate);
             // Paper end - per level difficulty
         }
@@ -1960,8 +1999,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private void updateMobSpawningFlags() {
-        for (ServerLevel serverLevel : this.getAllLevels()) {
-            serverLevel.setSpawnSettings(serverLevel.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
+        for (net.minecraft.server.level.ServerLevel serverLevel : this.getAllLevels()) {
+            serverLevel.setSpawnSettings(serverLevel.serverLevelData.getDifficulty() != net.minecraft.world.Difficulty.PEACEFUL && ((net.minecraft.server.dedicated.DedicatedServer) this).settings.getProperties().spawnMonsters); // Paper - per level difficulty (from setDifficulty(ServerLevel, Difficulty, boolean))
         }
     }
 
@@ -1970,13 +2009,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.getPlayerList().getPlayers().forEach(this::sendDifficultyUpdate);
     }
 
-    private void sendDifficultyUpdate(ServerPlayer player) {
-        LevelData levelData = player.level().getLevelData();
-        player.connection.send(new ClientboundChangeDifficultyPacket(levelData.getDifficulty(), levelData.isDifficultyLocked()));
+    private void sendDifficultyUpdate(net.minecraft.server.level.ServerPlayer player) {
+        net.minecraft.world.level.storage.LevelData levelData = player.level().getLevelData();
+        player.connection.send(new net.minecraft.network.protocol.game.ClientboundChangeDifficultyPacket(levelData.getDifficulty(), levelData.isDifficultyLocked()));
     }
 
     public boolean isSpawningMonsters() {
-        return this.worldData.getDifficulty() != Difficulty.PEACEFUL;
+        return this.worldData.getDifficulty() != net.minecraft.world.Difficulty.PEACEFUL;
     }
 
     public boolean isDemo() {
@@ -1987,12 +2026,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.isDemo = demo;
     }
 
-    public Optional<MinecraftServer.ServerResourcePackInfo> getServerResourcePack() {
-        return Optional.empty();
+    public java.util.Optional<net.minecraft.server.MinecraftServer.ServerResourcePackInfo> getServerResourcePack() {
+        return java.util.Optional.empty();
     }
 
     public boolean isResourcePackRequired() {
-        return this.getServerResourcePack().filter(MinecraftServer.ServerResourcePackInfo::isRequired).isPresent();
+        return this.getServerResourcePack().filter(net.minecraft.server.MinecraftServer.ServerResourcePackInfo::isRequired).isPresent();
     }
 
     public abstract boolean isDedicatedServer();
@@ -2058,22 +2097,22 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.stopped;
     }
 
-    public PlayerList getPlayerList() {
+    public net.minecraft.server.players.PlayerList getPlayerList() {
         return this.playerList;
     }
 
-    public void setPlayerList(PlayerList list) {
+    public void setPlayerList(net.minecraft.server.players.PlayerList list) {
         this.playerList = list;
     }
 
     public abstract boolean isPublished();
 
-    public void setDefaultGameType(GameType gameMode) {
+    public void setDefaultGameType(net.minecraft.world.level.GameType gameMode) {
         this.worldData.setGameType(gameMode);
     }
 
-    public ServerConnectionListener getConnection() {
-        return this.connection == null ? this.connection = new ServerConnectionListener(this) : this.connection; // Spigot
+    public net.minecraft.server.network.ServerConnectionListener getConnection() {
+        return this.connection == null ? this.connection = new net.minecraft.server.network.ServerConnectionListener(this) : this.connection; // Spigot
     }
 
     public boolean isReady() {
@@ -2084,7 +2123,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
-    public boolean publishServer(@Nullable GameType gameMode, boolean commands, int port) {
+    public boolean publishServer(@javax.annotation.Nullable net.minecraft.world.level.GameType gameMode, boolean commands, int port) {
         return false;
     }
 
@@ -2096,7 +2135,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return 16;
     }
 
-    public boolean isUnderSpawnProtection(ServerLevel level, BlockPos pos, Player player) {
+    public boolean isUnderSpawnProtection(net.minecraft.server.level.ServerLevel level, net.minecraft.core.BlockPos pos, net.minecraft.world.entity.player.Player player) {
         return false;
     }
 
@@ -2108,7 +2147,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
-    public Proxy getProxy() {
+    public java.net.Proxy getProxy() {
         return this.proxy;
     }
 
@@ -2120,26 +2159,26 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.playerIdleTimeout = idleTimeout;
     }
 
-    public MinecraftSessionService getSessionService() {
+    public com.mojang.authlib.minecraft.MinecraftSessionService getSessionService() {
         return this.services.sessionService();
     }
 
-    @Nullable
-    public SignatureValidator getProfileKeySignatureValidator() {
+    @javax.annotation.Nullable
+    public net.minecraft.util.SignatureValidator getProfileKeySignatureValidator() {
         return this.services.profileKeySignatureValidator();
     }
 
-    public GameProfileRepository getProfileRepository() {
+    public com.mojang.authlib.GameProfileRepository getProfileRepository() {
         return this.services.profileRepository();
     }
 
-    @Nullable
-    public GameProfileCache getProfileCache() {
+    @javax.annotation.Nullable
+    public net.minecraft.server.players.GameProfileCache getProfileCache() {
         return this.services.profileCache();
     }
 
-    @Nullable
-    public ServerStatus getStatus() {
+    @javax.annotation.Nullable
+    public net.minecraft.network.protocol.status.ServerStatus getStatus() {
         return this.status;
     }
 
@@ -2182,43 +2221,43 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.nextTickTimeNanos;
     }
 
-    public DataFixer getFixerUpper() {
+    public com.mojang.datafixers.DataFixer getFixerUpper() {
         return this.fixerUpper;
     }
 
-    public int getSpawnRadius(@Nullable ServerLevel level) {
-        return level != null ? level.getGameRules().getInt(GameRules.RULE_SPAWN_RADIUS) : 10;
+    public int getSpawnRadius(@javax.annotation.Nullable net.minecraft.server.level.ServerLevel level) {
+        return level != null ? level.getGameRules().getInt(net.minecraft.world.level.GameRules.RULE_SPAWN_RADIUS) : 10;
     }
 
-    public ServerAdvancementManager getAdvancements() {
+    public net.minecraft.server.ServerAdvancementManager getAdvancements() {
         return this.resources.managers.getAdvancements();
     }
 
-    public ServerFunctionManager getFunctions() {
+    public net.minecraft.server.ServerFunctionManager getFunctions() {
         return this.functionManager;
     }
 
     // Paper start - Add ServerResourcesReloadedEvent
     @Deprecated @io.papermc.paper.annotation.DoNotUse
-    public CompletableFuture<Void> reloadResources(Collection<String> selectedIds) {
+    public java.util.concurrent.CompletableFuture<Void> reloadResources(java.util.Collection<String> selectedIds) {
         return this.reloadResources(selectedIds, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN);
     }
-    public CompletableFuture<Void> reloadResources(Collection<String> selectedIds, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
+    public java.util.concurrent.CompletableFuture<Void> reloadResources(java.util.Collection<String> selectedIds, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
         // Paper end - Add ServerResourcesReloadedEvent
-        CompletableFuture<Void> completableFuture = CompletableFuture.<ImmutableList>supplyAsync(
-                () -> selectedIds.stream().map(this.packRepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()),
+        java.util.concurrent.CompletableFuture<Void> completableFuture = java.util.concurrent.CompletableFuture.<com.google.common.collect.ImmutableList>supplyAsync(
+                () -> selectedIds.stream().map(this.packRepository::getPack).filter(java.util.Objects::nonNull).map(net.minecraft.server.packs.repository.Pack::open).collect(com.google.common.collect.ImmutableList.toImmutableList()),
                 this
             )
             .thenCompose(
                 list -> {
-                    CloseableResourceManager closeableResourceManager = new MultiPackResourceManager(PackType.SERVER_DATA, list);
-                    List<Registry.PendingTags<?>> list1 = TagLoader.loadTagsForExistingRegistries(closeableResourceManager, this.registries.compositeAccess(), io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD); // Paper - tag lifecycle - add cause
-                    return ReloadableServerResources.loadResources(
+                    net.minecraft.server.packs.resources.CloseableResourceManager closeableResourceManager = new net.minecraft.server.packs.resources.MultiPackResourceManager(net.minecraft.server.packs.PackType.SERVER_DATA, list);
+                    java.util.List<net.minecraft.core.Registry.PendingTags<?>> list1 = net.minecraft.tags.TagLoader.loadTagsForExistingRegistries(closeableResourceManager, this.registries.compositeAccess(), io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD); // Paper - tag lifecycle - add cause
+                    return net.minecraft.server.ReloadableServerResources.loadResources(
                             closeableResourceManager,
                             this.registries,
                             list1,
                             this.worldData.enabledFeatures(),
-                            this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED,
+                            this.isDedicatedServer() ? net.minecraft.commands.Commands.CommandSelection.DEDICATED : net.minecraft.commands.Commands.CommandSelection.INTEGRATED,
                             this.getFunctionCompilationLevel(),
                             this.executor,
                             this
@@ -2228,7 +2267,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                                 closeableResourceManager.close();
                             }
                         })
-                        .thenApply(reloadableServerResources -> new MinecraftServer.ReloadableResources(closeableResourceManager, reloadableServerResources));
+                        .thenApply(reloadableServerResources -> new net.minecraft.server.MinecraftServer.ReloadableResources(closeableResourceManager, reloadableServerResources));
                 }
             )
             .thenAcceptAsync(
@@ -2237,7 +2276,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     this.resources.close();
                     this.resources = reloadableResources;
                     this.packRepository.setSelected(selectedIds, false); // Paper - add pendingReload flag to determine required pack loading - false as this is *after* a reload (see above)
-                    WorldDataConfiguration worldDataConfiguration = new WorldDataConfiguration(
+                    net.minecraft.world.level.WorldDataConfiguration worldDataConfiguration = new net.minecraft.world.level.WorldDataConfiguration(
                         getSelectedPacks(this.packRepository, true), this.worldData.enabledFeatures()
                     );
                     this.worldData.setDataConfiguration(worldDataConfiguration);
@@ -2247,14 +2286,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     if (Thread.currentThread() != this.serverThread) return; // Paper
                     // Paper start - we don't need to save everything, just advancements
                     // this.getPlayerList().saveAll();
-                    for (final ServerPlayer player : this.getPlayerList().getPlayers()) {
+                    for (final net.minecraft.server.level.ServerPlayer player : this.getPlayerList().getPlayers()) {
                         player.getAdvancements().save();
                     }
                     // Paper end - we don't need to save everything, just advancements
                     this.getPlayerList().reloadResources();
                     this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
                     this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
-                    this.fuelValues = FuelValues.vanillaBurnTimes(this.registries.compositeAccess(), this.worldData.enabledFeatures());
+                    this.fuelValues = net.minecraft.world.level.block.entity.FuelValues.vanillaBurnTimes(this.registries.compositeAccess(), this.worldData.enabledFeatures());
                     org.bukkit.craftbukkit.block.data.CraftBlockData.reloadCache(); // Paper - cache block data strings; they can be defined by datapacks so refresh it here
                     // Paper start - brigadier command API
                     io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setValid(); // reset invalid state for event fire below
@@ -2276,17 +2315,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return completableFuture;
     }
 
-    public static WorldDataConfiguration configurePackRepository(
-        PackRepository packRepository, WorldDataConfiguration initialDataConfig, boolean initMode, boolean safeMode
+    public static net.minecraft.world.level.WorldDataConfiguration configurePackRepository(
+        net.minecraft.server.packs.repository.PackRepository packRepository, net.minecraft.world.level.WorldDataConfiguration initialDataConfig, boolean initMode, boolean safeMode
     ) {
-        DataPackConfig dataPackConfig = initialDataConfig.dataPacks();
-        FeatureFlagSet featureFlagSet = initMode ? FeatureFlagSet.of() : initialDataConfig.enabledFeatures();
-        FeatureFlagSet featureFlagSet1 = initMode ? FeatureFlags.REGISTRY.allFlags() : initialDataConfig.enabledFeatures();
+        net.minecraft.world.level.DataPackConfig dataPackConfig = initialDataConfig.dataPacks();
+        net.minecraft.world.flag.FeatureFlagSet featureFlagSet = initMode ? net.minecraft.world.flag.FeatureFlagSet.of() : initialDataConfig.enabledFeatures();
+        net.minecraft.world.flag.FeatureFlagSet featureFlagSet1 = initMode ? net.minecraft.world.flag.FeatureFlags.REGISTRY.allFlags() : initialDataConfig.enabledFeatures();
         packRepository.reload(true); // Paper - will load resource packs
         if (safeMode) {
-            return configureRepositoryWithSelection(packRepository, List.of("vanilla"), featureFlagSet, false);
+            return configureRepositoryWithSelection(packRepository, java.util.List.of("vanilla"), featureFlagSet, false);
         } else {
-            Set<String> set = Sets.newLinkedHashSet();
+            java.util.Set<String> set = com.google.common.collect.Sets.newLinkedHashSet();
 
             for (String string : dataPackConfig.getEnabled()) {
                 if (packRepository.isAvailable(string)) {
@@ -2296,10 +2335,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
             }
 
-            for (Pack pack : packRepository.getAvailablePacks()) {
+            for (net.minecraft.server.packs.repository.Pack pack : packRepository.getAvailablePacks()) {
                 String id = pack.getId();
                 if (!dataPackConfig.getDisabled().contains(id)) {
-                    FeatureFlagSet requestedFeatures = pack.getRequestedFeatures();
+                    net.minecraft.world.flag.FeatureFlagSet requestedFeatures = pack.getRequestedFeatures();
                     boolean flag = set.contains(id);
                     if (!flag && pack.getPackSource().shouldAddAutomatically()) {
                         if (requestedFeatures.isSubsetOf(featureFlagSet1)) {
@@ -2309,7 +2348,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                             LOGGER.info(
                                 "Found new data pack {}, but can't load it due to missing features {}",
                                 id,
-                                FeatureFlags.printMissingFlags(featureFlagSet1, requestedFeatures)
+                                net.minecraft.world.flag.FeatureFlags.printMissingFlags(featureFlagSet1, requestedFeatures)
                             );
                         }
                     }
@@ -2318,7 +2357,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                         LOGGER.warn(
                             "Pack {} requires features {} that are not enabled for this world, disabling pack.",
                             id,
-                            FeatureFlags.printMissingFlags(featureFlagSet1, requestedFeatures)
+                            net.minecraft.world.flag.FeatureFlags.printMissingFlags(featureFlagSet1, requestedFeatures)
                         );
                         set.remove(id);
                     }
@@ -2334,30 +2373,30 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    private static WorldDataConfiguration configureRepositoryWithSelection(
-        PackRepository packRepository, Collection<String> selectedPacks, FeatureFlagSet enabledFeatures, boolean safeMode
+    private static net.minecraft.world.level.WorldDataConfiguration configureRepositoryWithSelection(
+        net.minecraft.server.packs.repository.PackRepository packRepository, java.util.Collection<String> selectedPacks, net.minecraft.world.flag.FeatureFlagSet enabledFeatures, boolean safeMode
     ) {
         packRepository.setSelected(selectedPacks, true); // Paper - add pendingReload flag to determine required pack loading - before the initial server load
         enableForcedFeaturePacks(packRepository, enabledFeatures);
-        DataPackConfig selectedPacks1 = getSelectedPacks(packRepository, safeMode);
-        FeatureFlagSet featureFlagSet = packRepository.getRequestedFeatureFlags().join(enabledFeatures);
-        return new WorldDataConfiguration(selectedPacks1, featureFlagSet);
+        net.minecraft.world.level.DataPackConfig selectedPacks1 = getSelectedPacks(packRepository, safeMode);
+        net.minecraft.world.flag.FeatureFlagSet featureFlagSet = packRepository.getRequestedFeatureFlags().join(enabledFeatures);
+        return new net.minecraft.world.level.WorldDataConfiguration(selectedPacks1, featureFlagSet);
     }
 
-    private static void enableForcedFeaturePacks(PackRepository packRepository, FeatureFlagSet enabledFeatures) {
-        FeatureFlagSet requestedFeatureFlags = packRepository.getRequestedFeatureFlags();
-        FeatureFlagSet featureFlagSet = enabledFeatures.subtract(requestedFeatureFlags);
+    private static void enableForcedFeaturePacks(net.minecraft.server.packs.repository.PackRepository packRepository, net.minecraft.world.flag.FeatureFlagSet enabledFeatures) {
+        net.minecraft.world.flag.FeatureFlagSet requestedFeatureFlags = packRepository.getRequestedFeatureFlags();
+        net.minecraft.world.flag.FeatureFlagSet featureFlagSet = enabledFeatures.subtract(requestedFeatureFlags);
         if (!featureFlagSet.isEmpty()) {
-            Set<String> set = new ObjectArraySet<>(packRepository.getSelectedIds());
+            java.util.Set<String> set = new it.unimi.dsi.fastutil.objects.ObjectArraySet<>(packRepository.getSelectedIds());
 
-            for (Pack pack : packRepository.getAvailablePacks()) {
+            for (net.minecraft.server.packs.repository.Pack pack : packRepository.getAvailablePacks()) {
                 if (featureFlagSet.isEmpty()) {
                     break;
                 }
 
-                if (pack.getPackSource() == PackSource.FEATURE) {
+                if (pack.getPackSource() == net.minecraft.server.packs.repository.PackSource.FEATURE) {
                     String id = pack.getId();
-                    FeatureFlagSet requestedFeatures = pack.getRequestedFeatures();
+                    net.minecraft.world.flag.FeatureFlagSet requestedFeatures = pack.getRequestedFeatures();
                     if (!requestedFeatures.isEmpty() && requestedFeatures.intersects(featureFlagSet) && requestedFeatures.isSubsetOf(enabledFeatures)) {
                         if (!set.add(id)) {
                             throw new IllegalStateException("Tried to force '" + id + "', but it was already enabled");
@@ -2373,20 +2412,20 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    private static DataPackConfig getSelectedPacks(PackRepository packRepository, boolean safeMode) {
-        Collection<String> selectedIds = packRepository.getSelectedIds();
-        List<String> list = ImmutableList.copyOf(selectedIds);
-        List<String> list1 = safeMode ? packRepository.getAvailableIds().stream().filter(packId -> !selectedIds.contains(packId)).toList() : List.of();
-        return new DataPackConfig(list, list1);
+    private static net.minecraft.world.level.DataPackConfig getSelectedPacks(net.minecraft.server.packs.repository.PackRepository packRepository, boolean safeMode) {
+        java.util.Collection<String> selectedIds = packRepository.getSelectedIds();
+        java.util.List<String> list = com.google.common.collect.ImmutableList.copyOf(selectedIds);
+        java.util.List<String> list1 = safeMode ? packRepository.getAvailableIds().stream().filter(packId -> !selectedIds.contains(packId)).toList() : java.util.List.of();
+        return new net.minecraft.world.level.DataPackConfig(list, list1);
     }
 
-    public void kickUnlistedPlayers(CommandSourceStack commandSource) {
+    public void kickUnlistedPlayers(net.minecraft.commands.CommandSourceStack commandSource) {
         if (this.isEnforceWhitelist()) {
-            PlayerList playerList = commandSource.getServer().getPlayerList();
+            net.minecraft.server.players.PlayerList playerList = commandSource.getServer().getPlayerList();
             if (!playerList.isUsingWhitelist()) return; // Paper - whitelist not enabled
-            UserWhiteList whiteList = playerList.getWhiteList();
+            net.minecraft.server.players.UserWhiteList whiteList = playerList.getWhiteList();
 
-            for (ServerPlayer serverPlayer : Lists.newArrayList(playerList.getPlayers())) {
+            for (net.minecraft.server.level.ServerPlayer serverPlayer : com.google.common.collect.Lists.newArrayList(playerList.getPlayers())) {
                 if (!whiteList.isWhiteListed(serverPlayer.getGameProfile()) && !this.getPlayerList().isOp(serverPlayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
                     serverPlayer.connection.disconnect(net.kyori.adventure.text.Component.text(org.spigotmc.SpigotConfig.whitelistMessage), org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message & kick event cause
                 }
@@ -2394,24 +2433,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public PackRepository getPackRepository() {
+    public net.minecraft.server.packs.repository.PackRepository getPackRepository() {
         return this.packRepository;
     }
 
-    public Commands getCommands() {
+    public net.minecraft.commands.Commands getCommands() {
         return this.resources.managers.getCommands();
     }
 
-    public CommandSourceStack createCommandSourceStack() {
-        ServerLevel serverLevel = this.overworld();
-        return new CommandSourceStack(
+    public net.minecraft.commands.CommandSourceStack createCommandSourceStack() {
+        net.minecraft.server.level.ServerLevel serverLevel = this.overworld();
+        return new net.minecraft.commands.CommandSourceStack(
             this,
-            serverLevel == null ? Vec3.ZERO : Vec3.atLowerCornerOf(serverLevel.getSharedSpawnPos()),
-            Vec2.ZERO,
+            serverLevel == null ? net.minecraft.world.phys.Vec3.ZERO : net.minecraft.world.phys.Vec3.atLowerCornerOf(serverLevel.getSharedSpawnPos()),
+            net.minecraft.world.phys.Vec2.ZERO,
             serverLevel,
             4,
             "Server",
-            Component.literal("Server"),
+            net.minecraft.network.chat.Component.literal("Server"),
             this,
             null
         );
@@ -2430,15 +2469,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     @Override
     public abstract boolean shouldInformAdmins();
 
-    public RecipeManager getRecipeManager() {
+    public net.minecraft.world.item.crafting.RecipeManager getRecipeManager() {
         return this.resources.managers.getRecipeManager();
     }
 
-    public ServerScoreboard getScoreboard() {
+    public net.minecraft.server.ServerScoreboard getScoreboard() {
         return this.scoreboard;
     }
 
-    public CommandStorage getCommandStorage() {
+    public net.minecraft.world.level.storage.CommandStorage getCommandStorage() {
         if (this.commandStorage == null) {
             throw new NullPointerException("Called before server init");
         } else {
@@ -2446,11 +2485,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public GameRules getGameRules() {
+    public net.minecraft.world.level.GameRules getGameRules() {
         return this.overworld().getGameRules();
     }
 
-    public CustomBossEvents getCustomBossEvents() {
+    public net.minecraft.server.bossevents.CustomBossEvents getCustomBossEvents() {
         return this.customBossEvents;
     }
 
@@ -2466,7 +2505,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.smoothedTickTimeMillis;
     }
 
-    public ServerTickRateManager tickRateManager() {
+    public net.minecraft.server.ServerTickRateManager tickRateManager() {
         return this.tickRateManager;
     }
 
@@ -2478,9 +2517,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.tickTimesNanos;
     }
 
-    public int getProfilePermissions(GameProfile profile) {
+    public int getProfilePermissions(com.mojang.authlib.GameProfile profile) {
         if (this.getPlayerList().isOp(profile)) {
-            ServerOpListEntry serverOpListEntry = this.getPlayerList().getOps().get(profile);
+            net.minecraft.server.players.ServerOpListEntry serverOpListEntry = this.getPlayerList().getOps().get(profile);
             if (serverOpListEntry != null) {
                 return serverOpListEntry.getLevel();
             } else if (this.isSingleplayerOwner(profile)) {
@@ -2495,19 +2534,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public abstract boolean isSingleplayerOwner(GameProfile profile);
+    public abstract boolean isSingleplayerOwner(com.mojang.authlib.GameProfile profile);
 
-    public void dumpServerProperties(Path path) throws IOException {
+    public void dumpServerProperties(java.nio.file.Path path) throws java.io.IOException {
     }
 
-    private void saveDebugReport(Path path) {
-        Path path1 = path.resolve("levels");
+    private void saveDebugReport(java.nio.file.Path path) {
+        java.nio.file.Path path1 = path.resolve("levels");
 
         try {
-            for (Entry<ResourceKey<Level>, ServerLevel> entry : this.levels.entrySet()) {
-                ResourceLocation resourceLocation = entry.getKey().location();
-                Path path2 = path1.resolve(resourceLocation.getNamespace()).resolve(resourceLocation.getPath());
-                Files.createDirectories(path2);
+            for (java.util.Map.Entry<net.minecraft.resources.ResourceKey<net.minecraft.world.level.Level>, net.minecraft.server.level.ServerLevel> entry : this.levels.entrySet()) {
+                net.minecraft.resources.ResourceLocation resourceLocation = entry.getKey().location();
+                java.nio.file.Path path2 = path1.resolve(resourceLocation.getNamespace()).resolve(resourceLocation.getPath());
+                java.nio.file.Files.createDirectories(path2);
                 entry.getValue().saveDebugReport(path2);
             }
 
@@ -2517,28 +2556,28 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.dumpThreads(path.resolve("threads.txt"));
             this.dumpServerProperties(path.resolve("server.properties.txt"));
             this.dumpNativeModules(path.resolve("modules.txt"));
-        } catch (IOException var7) {
+        } catch (java.io.IOException var7) {
             LOGGER.warn("Failed to save debug report", (Throwable)var7);
         }
     }
 
-    private void dumpMiscStats(Path path) throws IOException {
-        try (Writer bufferedWriter = Files.newBufferedWriter(path)) {
-            bufferedWriter.write(String.format(Locale.ROOT, "pending_tasks: %d\n", this.getPendingTasksCount()));
-            bufferedWriter.write(String.format(Locale.ROOT, "average_tick_time: %f\n", this.getCurrentSmoothedTickTime()));
-            bufferedWriter.write(String.format(Locale.ROOT, "tick_times: %s\n", Arrays.toString(this.tickTimesNanos)));
-            bufferedWriter.write(String.format(Locale.ROOT, "queue: %s\n", Util.backgroundExecutor()));
+    private void dumpMiscStats(java.nio.file.Path path) throws java.io.IOException {
+        try (java.io.Writer bufferedWriter = java.nio.file.Files.newBufferedWriter(path)) {
+            bufferedWriter.write(String.format(java.util.Locale.ROOT, "pending_tasks: %d\n", this.getPendingTasksCount()));
+            bufferedWriter.write(String.format(java.util.Locale.ROOT, "average_tick_time: %f\n", this.getCurrentSmoothedTickTime()));
+            bufferedWriter.write(String.format(java.util.Locale.ROOT, "tick_times: %s\n", java.util.Arrays.toString(this.tickTimesNanos)));
+            bufferedWriter.write(String.format(java.util.Locale.ROOT, "queue: %s\n", net.minecraft.Util.backgroundExecutor()));
         }
     }
 
-    private void dumpGameRules(Path path) throws IOException {
-        try (Writer bufferedWriter = Files.newBufferedWriter(path)) {
-            final List<String> list = Lists.newArrayList();
-            final GameRules gameRules = this.getGameRules();
-            gameRules.visitGameRuleTypes(new GameRules.GameRuleTypeVisitor() {
+    private void dumpGameRules(java.nio.file.Path path) throws java.io.IOException {
+        try (java.io.Writer bufferedWriter = java.nio.file.Files.newBufferedWriter(path)) {
+            final java.util.List<String> list = com.google.common.collect.Lists.newArrayList();
+            final net.minecraft.world.level.GameRules gameRules = this.getGameRules();
+            gameRules.visitGameRuleTypes(new net.minecraft.world.level.GameRules.GameRuleTypeVisitor() {
                 @Override
-                public <T extends GameRules.Value<T>> void visit(GameRules.Key<T> key, GameRules.Type<T> type) {
-                    list.add(String.format(Locale.ROOT, "%s=%s\n", key.getId(), gameRules.getRule(key)));
+                public <T extends net.minecraft.world.level.GameRules.Value<T>> void visit(net.minecraft.world.level.GameRules.Key<T> key, net.minecraft.world.level.GameRules.Type<T> type) {
+                    list.add(String.format(java.util.Locale.ROOT, "%s=%s\n", key.getId(), gameRules.getRule(key)));
                 }
             });
 
@@ -2548,44 +2587,44 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    private void dumpClasspath(Path path) throws IOException {
-        try (Writer bufferedWriter = Files.newBufferedWriter(path)) {
+    private void dumpClasspath(java.nio.file.Path path) throws java.io.IOException {
+        try (java.io.Writer bufferedWriter = java.nio.file.Files.newBufferedWriter(path)) {
             String property = System.getProperty("java.class.path");
             String property1 = System.getProperty("path.separator");
 
-            for (String string : Splitter.on(property1).split(property)) {
+            for (String string : com.google.common.base.Splitter.on(property1).split(property)) {
                 bufferedWriter.write(string);
                 bufferedWriter.write("\n");
             }
         }
     }
 
-    private void dumpThreads(Path path) throws IOException {
-        ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
-        ThreadInfo[] threadInfos = threadMxBean.dumpAllThreads(true, true);
-        Arrays.sort(threadInfos, Comparator.comparing(ThreadInfo::getThreadName));
+    private void dumpThreads(java.nio.file.Path path) throws java.io.IOException {
+        java.lang.management.ThreadMXBean threadMxBean = java.lang.management.ManagementFactory.getThreadMXBean();
+        java.lang.management.ThreadInfo[] threadInfos = threadMxBean.dumpAllThreads(true, true);
+        java.util.Arrays.sort(threadInfos, java.util.Comparator.comparing(java.lang.management.ThreadInfo::getThreadName));
 
-        try (Writer bufferedWriter = Files.newBufferedWriter(path)) {
-            for (ThreadInfo threadInfo : threadInfos) {
+        try (java.io.Writer bufferedWriter = java.nio.file.Files.newBufferedWriter(path)) {
+            for (java.lang.management.ThreadInfo threadInfo : threadInfos) {
                 bufferedWriter.write(threadInfo.toString());
                 bufferedWriter.write(10);
             }
         }
     }
 
-    private void dumpNativeModules(Path path) throws IOException {
-        try (Writer bufferedWriter = Files.newBufferedWriter(path)) {
-            List<NativeModuleLister.NativeModuleInfo> list;
+    private void dumpNativeModules(java.nio.file.Path path) throws java.io.IOException {
+        try (java.io.Writer bufferedWriter = java.nio.file.Files.newBufferedWriter(path)) {
+            java.util.List<net.minecraft.util.NativeModuleLister.NativeModuleInfo> list;
             try {
-                list = Lists.newArrayList(NativeModuleLister.listModules());
+                list = com.google.common.collect.Lists.newArrayList(net.minecraft.util.NativeModuleLister.listModules());
             } catch (Throwable var7) {
                 LOGGER.warn("Failed to list native modules", var7);
                 return;
             }
 
-            list.sort(Comparator.comparing(nativeModuleInfo1 -> nativeModuleInfo1.name));
+            list.sort(java.util.Comparator.comparing(nativeModuleInfo1 -> nativeModuleInfo1.name));
 
-            for (NativeModuleLister.NativeModuleInfo nativeModuleInfo : list) {
+            for (net.minecraft.util.NativeModuleLister.NativeModuleInfo nativeModuleInfo : list) {
                 bufferedWriter.write(nativeModuleInfo.toString());
                 bufferedWriter.write(10);
             }
@@ -2604,23 +2643,23 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return false;
     }
 
-    public static MinecraftServer getServer() {
+    public static net.minecraft.server.MinecraftServer getServer() {
         return SERVER; // Paper
     }
 
     @Deprecated
-    public static RegistryAccess getDefaultRegistryAccess() {
+    public static net.minecraft.core.RegistryAccess getDefaultRegistryAccess() {
         return org.bukkit.craftbukkit.CraftRegistry.getMinecraftRegistry();
     }
     // CraftBukkit end
 
-    private ProfilerFiller createProfiler() {
+    private net.minecraft.util.profiling.ProfilerFiller createProfiler() {
         if (this.willStartRecordingMetrics) {
-            this.metricsRecorder = ActiveMetricsRecorder.createStarted(
-                new ServerMetricsSamplersProvider(Util.timeSource, this.isDedicatedServer()),
-                Util.timeSource,
-                Util.ioPool(),
-                new MetricsPersister("server"),
+            this.metricsRecorder = net.minecraft.util.profiling.metrics.profiling.ActiveMetricsRecorder.createStarted(
+                new net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvider(net.minecraft.Util.timeSource, this.isDedicatedServer()),
+                net.minecraft.Util.timeSource,
+                net.minecraft.Util.ioPool(),
+                new net.minecraft.util.profiling.metrics.storage.MetricsPersister("server"),
                 this.onMetricsRecordingStopped,
                 path -> {
                     this.executeBlocking(() -> this.saveDebugReport(path.resolve("server")));
@@ -2631,7 +2670,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         this.metricsRecorder.startTick();
-        return SingleTickProfiler.decorateFiller(this.metricsRecorder.getProfiler(), SingleTickProfiler.createTickProfiler("Server"));
+        return net.minecraft.util.profiling.SingleTickProfiler.decorateFiller(this.metricsRecorder.getProfiler(), net.minecraft.util.profiling.SingleTickProfiler.createTickProfiler("Server"));
     }
 
     public void endMetricsRecordingTick() {
@@ -2642,7 +2681,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return this.metricsRecorder.isRecording();
     }
 
-    public void startRecordingMetrics(Consumer<ProfileResults> output, Consumer<Path> onMetricsRecordingFinished) {
+    public void startRecordingMetrics(java.util.function.Consumer<net.minecraft.util.profiling.ProfileResults> output, java.util.function.Consumer<java.nio.file.Path> onMetricsRecordingFinished) {
         this.onMetricsRecordingStopped = profileResults -> {
             this.stopRecordingMetrics();
             output.accept(profileResults);
@@ -2652,7 +2691,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public void stopRecordingMetrics() {
-        this.metricsRecorder = InactiveMetricsRecorder.INSTANCE;
+        this.metricsRecorder = net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder.INSTANCE;
     }
 
     public void finishRecordingMetrics() {
@@ -2663,7 +2702,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.metricsRecorder.cancel();
     }
 
-    public Path getWorldPath(LevelResource levelResource) {
+    public java.nio.file.Path getWorldPath(net.minecraft.world.level.storage.LevelResource levelResource) {
         return this.storageSource.getLevelPath(levelResource);
     }
 
@@ -2671,40 +2710,40 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return true;
     }
 
-    public StructureTemplateManager getStructureManager() {
+    public net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager getStructureManager() {
         return this.structureTemplateManager;
     }
 
-    public WorldData getWorldData() {
+    public net.minecraft.world.level.storage.WorldData getWorldData() {
         return this.worldData;
     }
 
-    public RegistryAccess.Frozen registryAccess() {
+    public net.minecraft.core.RegistryAccess.Frozen registryAccess() {
         return this.registries.compositeAccess();
     }
 
-    public LayeredRegistryAccess<RegistryLayer> registries() {
+    public net.minecraft.core.LayeredRegistryAccess<net.minecraft.server.RegistryLayer> registries() {
         return this.registries;
     }
 
-    public ReloadableServerRegistries.Holder reloadableRegistries() {
+    public net.minecraft.server.ReloadableServerRegistries.Holder reloadableRegistries() {
         return this.resources.managers.fullRegistries();
     }
 
-    public TextFilter createTextFilterForPlayer(ServerPlayer player) {
-        return TextFilter.DUMMY;
+    public net.minecraft.server.network.TextFilter createTextFilterForPlayer(net.minecraft.server.level.ServerPlayer player) {
+        return net.minecraft.server.network.TextFilter.DUMMY;
     }
 
-    public ServerPlayerGameMode createGameModeForPlayer(ServerPlayer player) {
-        return (ServerPlayerGameMode)(this.isDemo() ? new DemoMode(player) : new ServerPlayerGameMode(player));
+    public net.minecraft.server.level.ServerPlayerGameMode createGameModeForPlayer(net.minecraft.server.level.ServerPlayer player) {
+        return (net.minecraft.server.level.ServerPlayerGameMode)(this.isDemo() ? new net.minecraft.server.level.DemoMode(player) : new net.minecraft.server.level.ServerPlayerGameMode(player));
     }
 
-    @Nullable
-    public GameType getForcedGameType() {
+    @javax.annotation.Nullable
+    public net.minecraft.world.level.GameType getForcedGameType() {
         return null;
     }
 
-    public ResourceManager getResourceManager() {
+    public net.minecraft.server.packs.resources.ResourceManager getResourceManager() {
         return this.resources.resourceManager;
     }
 
@@ -2720,11 +2759,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.debugCommandProfilerDelayStart = true;
     }
 
-    public ProfileResults stopTimeProfiler() {
+    public net.minecraft.util.profiling.ProfileResults stopTimeProfiler() {
         if (this.debugCommandProfiler == null) {
-            return EmptyProfileResults.EMPTY;
+            return net.minecraft.util.profiling.EmptyProfileResults.EMPTY;
         } else {
-            ProfileResults profileResults = this.debugCommandProfiler.stop(Util.getNanos(), this.tickCount);
+            net.minecraft.util.profiling.ProfileResults profileResults = this.debugCommandProfiler.stop(net.minecraft.Util.getNanos(), this.tickCount);
             this.debugCommandProfiler = null;
             return profileResults;
         }
@@ -2734,7 +2773,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return 1000000;
     }
 
-    public void logChatMessage(Component content, ChatType.Bound boundChatType, @Nullable String header) {
+    public void logChatMessage(net.minecraft.network.chat.Component content, net.minecraft.network.chat.ChatType.Bound boundChatType, @javax.annotation.Nullable String header) {
         // Paper start
         net.kyori.adventure.text.Component string = io.papermc.paper.adventure.PaperAdventure.asAdventure(boundChatType.decorate(content));
         if (header != null) {
@@ -2746,10 +2785,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
-        new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
-    public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
+        new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER)).build()); // Paper
+    public final net.minecraft.network.chat.ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
 
-    public ChatDecorator getChatDecorator() {
+    public net.minecraft.network.chat.ChatDecorator getChatDecorator() {
         return this.improvedChatDecorator; // Paper - support async chat decoration events
     }
 
@@ -2757,33 +2796,33 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return true;
     }
 
-    public void subscribeToDebugSample(ServerPlayer player, RemoteDebugSampleType sampleType) {
+    public void subscribeToDebugSample(net.minecraft.server.level.ServerPlayer player, net.minecraft.util.debugchart.RemoteDebugSampleType sampleType) {
     }
 
     public boolean acceptsTransfers() {
         return false;
     }
 
-    private void storeChunkIoError(CrashReport crashReport, ChunkPos chunkPos, RegionStorageInfo regionStorageInfo) {
-        Util.ioPool().execute(() -> {
+    private void storeChunkIoError(net.minecraft.CrashReport crashReport, net.minecraft.world.level.ChunkPos chunkPos, net.minecraft.world.level.chunk.storage.RegionStorageInfo regionStorageInfo) {
+        net.minecraft.Util.ioPool().execute(() -> {
             try {
-                Path file = this.getFile("debug");
-                FileUtil.createDirectoriesSafe(file);
-                String string = FileUtil.sanitizeName(regionStorageInfo.level());
-                Path path = file.resolve("chunk-" + string + "-" + Util.getFilenameFormattedDateTime() + "-server.txt");
-                FileStore fileStore = Files.getFileStore(file);
+                java.nio.file.Path file = this.getFile("debug");
+                net.minecraft.FileUtil.createDirectoriesSafe(file);
+                String string = net.minecraft.FileUtil.sanitizeName(regionStorageInfo.level());
+                java.nio.file.Path path = file.resolve("chunk-" + string + "-" + net.minecraft.Util.getFilenameFormattedDateTime() + "-server.txt");
+                java.nio.file.FileStore fileStore = java.nio.file.Files.getFileStore(file);
                 long usableSpace = fileStore.getUsableSpace();
                 if (usableSpace < 8192L) {
                     LOGGER.warn("Not storing chunk IO report due to low space on drive {}", fileStore.name());
                     return;
                 }
 
-                CrashReportCategory crashReportCategory = crashReport.addCategory("Chunk Info");
+                net.minecraft.CrashReportCategory crashReportCategory = crashReport.addCategory("Chunk Info");
                 crashReportCategory.setDetail("Level", regionStorageInfo::level);
                 crashReportCategory.setDetail("Dimension", () -> regionStorageInfo.dimension().location().toString());
                 crashReportCategory.setDetail("Storage", regionStorageInfo::type);
                 crashReportCategory.setDetail("Position", chunkPos::toString);
-                crashReport.saveToFile(path, ReportType.CHUNK_IO_ERROR);
+                crashReport.saveToFile(path, net.minecraft.ReportType.CHUNK_IO_ERROR);
                 LOGGER.info("Saved details to {}", crashReport.getSaveFile());
             } catch (Exception var11) {
                 LOGGER.warn("Failed to store chunk IO exception", (Throwable)var11);
@@ -2792,47 +2831,47 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     @Override
-    public void reportChunkLoadFailure(Throwable throwable, RegionStorageInfo regionStorageInfo, ChunkPos chunkPos) {
+    public void reportChunkLoadFailure(Throwable throwable, net.minecraft.world.level.chunk.storage.RegionStorageInfo regionStorageInfo, net.minecraft.world.level.ChunkPos chunkPos) {
         LOGGER.error("Failed to load chunk {},{}", chunkPos.x, chunkPos.z, throwable);
         this.suppressedExceptions.addEntry("chunk/load", throwable);
-        this.storeChunkIoError(CrashReport.forThrowable(throwable, "Chunk load failure"), chunkPos, regionStorageInfo);
+        this.storeChunkIoError(net.minecraft.CrashReport.forThrowable(throwable, "Chunk load failure"), chunkPos, regionStorageInfo);
     }
 
     @Override
-    public void reportChunkSaveFailure(Throwable throwable, RegionStorageInfo regionStorageInfo, ChunkPos chunkPos) {
+    public void reportChunkSaveFailure(Throwable throwable, net.minecraft.world.level.chunk.storage.RegionStorageInfo regionStorageInfo, net.minecraft.world.level.ChunkPos chunkPos) {
         LOGGER.error("Failed to save chunk {},{}", chunkPos.x, chunkPos.z, throwable);
         this.suppressedExceptions.addEntry("chunk/save", throwable);
-        this.storeChunkIoError(CrashReport.forThrowable(throwable, "Chunk save failure"), chunkPos, regionStorageInfo);
+        this.storeChunkIoError(net.minecraft.CrashReport.forThrowable(throwable, "Chunk save failure"), chunkPos, regionStorageInfo);
     }
 
-    public void reportPacketHandlingException(Throwable throwable, PacketType<?> packetType) {
+    public void reportPacketHandlingException(Throwable throwable, net.minecraft.network.protocol.PacketType<?> packetType) {
         this.suppressedExceptions.addEntry("packet/" + packetType.toString(), throwable);
     }
 
-    public PotionBrewing potionBrewing() {
+    public net.minecraft.world.item.alchemy.PotionBrewing potionBrewing() {
         return this.potionBrewing;
     }
 
-    public FuelValues fuelValues() {
+    public net.minecraft.world.level.block.entity.FuelValues fuelValues() {
         return this.fuelValues;
     }
 
-    public ServerLinks serverLinks() {
-        return ServerLinks.EMPTY;
+    public net.minecraft.server.ServerLinks serverLinks() {
+        return net.minecraft.server.ServerLinks.EMPTY;
     }
 
     protected int pauseWhileEmptySeconds() {
         return 0;
     }
 
-    public record ReloadableResources(CloseableResourceManager resourceManager, ReloadableServerResources managers) implements AutoCloseable {
+    public record ReloadableResources(net.minecraft.server.packs.resources.CloseableResourceManager resourceManager, net.minecraft.server.ReloadableServerResources managers) implements AutoCloseable {
         @Override
         public void close() {
             this.resourceManager.close();
         }
     }
 
-    public record ServerResourcePackInfo(UUID id, String url, String hash, boolean isRequired, @Nullable Component prompt) {
+    public record ServerResourcePackInfo(java.util.UUID id, String url, String hash, boolean isRequired, @javax.annotation.Nullable net.minecraft.network.chat.Component prompt) {
     }
 
     static class TimeProfiler {
@@ -2844,26 +2883,26 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.startTick = startTick;
         }
 
-        ProfileResults stop(final long endTimeNano, final int endTimeTicks) {
-            return new ProfileResults() {
+        net.minecraft.util.profiling.ProfileResults stop(final long endTimeNano, final int endTimeTicks) {
+            return new net.minecraft.util.profiling.ProfileResults() {
                 @Override
-                public List<ResultField> getTimes(String sectionPath) {
-                    return Collections.emptyList();
+                public java.util.List<net.minecraft.util.profiling.ResultField> getTimes(String sectionPath) {
+                    return java.util.Collections.emptyList();
                 }
 
                 @Override
-                public boolean saveResults(Path path) {
+                public boolean saveResults(java.nio.file.Path path) {
                     return false;
                 }
 
                 @Override
                 public long getStartTimeNano() {
-                    return TimeProfiler.this.startNanos;
+                    return net.minecraft.server.MinecraftServer.TimeProfiler.this.startNanos;
                 }
 
                 @Override
                 public int getStartTimeTicks() {
-                    return TimeProfiler.this.startTick;
+                    return net.minecraft.server.MinecraftServer.TimeProfiler.this.startTick;
                 }
 
                 @Override
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index 97a294d2f5c1ddf0af7ffec3e1425eb329c5751b..82271032b0ab3e6d634763b9011eca7a93b0cc87 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -224,6 +224,9 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
+        serverLevelTickingSemaphore = new java.util.concurrent.Semaphore(properties.worldTickThreads); // SparklyPaper - parallel world ticking
+        DedicatedServer.LOGGER.info("Using " + serverLevelTickingSemaphore.availablePermits() + " permits for parallel world ticking"); // SparklyPaper - parallel world ticking
+        // SparklyPaper end
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
 
         this.setPvpAllowed(properties.pvp);
diff --git a/net/minecraft/server/dedicated/DedicatedServerProperties.java b/net/minecraft/server/dedicated/DedicatedServerProperties.java
index f6518e29f805018c72222f5aaa7b662071665b65..df69cd598d0cf9dbba739326e2f1aed13fdd4cb2 100644
--- a/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -77,6 +77,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     public final int opPermissionLevel = this.get("op-permission-level", 4);
     public final int functionPermissionLevel = this.get("function-permission-level", 2);
     public final long maxTickTime = this.get("max-tick-time", TimeUnit.MINUTES.toMillis(1L));
+    public final int worldTickThreads = this.get("world-tick-threads", 1); // Aincrad - parallel world ticking
     public final int maxChainedNeighborUpdates = this.get("max-chained-neighbor-updates", 1000000);
     public final int rateLimitPacketsPerSecond = this.get("rate-limit", 0);
     public final int viewDistance = this.get("view-distance", 10);
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index e6733c43d582c1c632ad0e6abc99e88e337c8911..136954302d974d7360c15651b0c8a46d2752edcf 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -184,7 +184,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
     private int lastSpawnChunkRadius;
-    final EntityTickList entityTickList = new EntityTickList();
+    final EntityTickList entityTickList = new EntityTickList(this); // SparklyPaper - parallel world ticking
     // Paper - rewrite chunk system
     private final GameEventDispatcher gameEventDispatcher;
     public boolean noSave;
@@ -208,6 +208,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private final RandomSequences randomSequences;
+    public java.util.concurrent.ExecutorService tickExecutor; // SparklyPaper - parallel world ticking
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess levelStorageAccess;
@@ -570,6 +571,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
     // Paper end - chunk tick iteration
 
+    // SparklyPaper start - track world's MSPT
+    public final MinecraftServer.TickTimes tickTimes5s = new MinecraftServer.TickTimes(100);
+    public final MinecraftServer.TickTimes tickTimes10s = new MinecraftServer.TickTimes(200);
+    public final MinecraftServer.TickTimes tickTimes60s = new MinecraftServer.TickTimes(1200);
+    // SparklyPaper end
+
     public ServerLevel(
         MinecraftServer server,
         Executor dispatcher,
@@ -681,6 +688,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        this.tickExecutor = java.util.concurrent.Executors.newSingleThreadExecutor(new org.evlis.ServerLevelTickExecutorThreadFactory(getWorld().getName())); // SparklyPaper - parallel world ticking
     }
 
     // Paper start
@@ -1219,8 +1227,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             fluidState.tick(this, pos, blockState);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+        if ((++this.tickedBlocksOrFluids & 7L) != 0L) { // TO-DO: fix this empty if
+            // ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks(); // SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
         }
         // Paper end - rewrite chunk system
 
@@ -1232,8 +1240,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             blockState.tick(this, pos, this.random);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+        if ((++this.tickedBlocksOrFluids & 7L) != 0L) { // TO-DO: fix this empty if
+            // ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks(); // SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
         }
         // Paper end - rewrite chunk system
 
@@ -1493,6 +1501,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     private void addPlayer(ServerPlayer player) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add player off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         Entity entity = this.getEntities().get(player.getUUID());
         if (entity != null) {
             LOGGER.warn("Force-added player with duplicate UUID {}", player.getUUID());
@@ -1505,7 +1514,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     // CraftBukkit start
     private boolean addEntity(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
-        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add entity off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         entity.generation = false; // Paper - Don't fire sync event during generation; Reset flag if it was added during a ServerLevel generation process
         // Paper start - extra debug info
         if (entity.valid) {
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 57d432dc9e8d8e9a3e088e7c40b35178c30fe786..87bd9dbb7eb5b9bf7407aa49e155e56c9a63d3d7 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -423,6 +423,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         return this.viewDistanceHolder;
     }
     // Paper end - rewrite chunk system
+    public boolean hasTickedAtLeastOnceInNewWorld = false; // SparklyPaper - parallel world ticking (fixes bug in DreamResourceReset where the inventory is opened AFTER the player has changed worlds, if you click with the quick tp torch in a chest, because the inventory is opened AFTER the player has teleported)
 
     public ServerPlayer(MinecraftServer server, ServerLevel level, GameProfile gameProfile, ClientInformation clientInformation) {
         super(level, level.getSharedSpawnPos(), level.getSharedSpawnAngle(), gameProfile);
@@ -792,6 +793,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     @Override
     public void tick() {
+        hasTickedAtLeastOnceInNewWorld = true; // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         // CraftBukkit start
         if (this.joining) {
             this.joining = false;
@@ -1415,6 +1417,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 return this;
             } else {
                 // CraftBukkit start
+                ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot change dimension of a player off-main, from world " + serverLevel().getWorld().getName() + " to world " + level.getWorld().getName()); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
                 /*
                 this.isChangingDimension = true;
                 LevelData levelData = level.getLevelData();
@@ -1768,6 +1771,12 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 return OptionalInt.empty();
             } else {
                 // CraftBukkit start
+                // SparklyPaper start - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+                if (!hasTickedAtLeastOnceInNewWorld) {
+                    MinecraftServer.LOGGER.warn("Ignoring request to open container " + abstractContainerMenu + " because we haven't ticked in the current world yet!", new Throwable());
+                    return OptionalInt.empty();
+                }
+                // SparklyPaper end
                 this.containerMenu = abstractContainerMenu; // Moved up
                 if (!this.isImmobile())
                 this.connection
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 5a4960fdbd97d830ac79845697eea9372c48a13b..76c17bc3425a081a0d691a10525f91b3b930ebd0 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -113,7 +113,7 @@ public abstract class PlayerList {
     private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
+    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap(); // SparklyPaper - parallel world ticking (we don't need to replace the original map because we never iterate on top of this map)
     private final UserBanList bans = new UserBanList(USERBANLIST_FILE);
     private final IpBanList ipBans = new IpBanList(IPBANLIST_FILE);
     private final ServerOpList ops = new ServerOpList(OPLIST_FILE);
@@ -134,7 +134,7 @@ public abstract class PlayerList {
 
     // CraftBukkit start
     private org.bukkit.craftbukkit.CraftServer cserver;
-    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>(); // SparklyPaper - parallel world ticking (we don't need to replace the original map because we never iterate on top of this map)
     public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
 
     public PlayerList(MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registries, PlayerDataStorage playerIo, int maxPlayers) {
@@ -150,6 +150,7 @@ public abstract class PlayerList {
     abstract public void loadAndSaveFiles(); // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
 
     public void placeNewPlayer(Connection connection, ServerPlayer player, CommonListenerCookie cookie) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot place new player off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         player.isRealPlayer = true; // Paper
         player.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
         GameProfile gameProfile = player.getGameProfile();
@@ -714,6 +715,13 @@ public abstract class PlayerList {
         return this.respawn(player, keepInventory, reason, eventReason, null);
     }
     public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason eventReason, org.bukkit.Location location) {
+        System.out.println("respawning player - current player container is " + player.containerMenu + " but their inventory is " + player.inventoryMenu);
+        // SparklyPaper - parallel world ticking (additional concurrency issues logs)
+        if (location != null) // TODO: Is this really never null, or is IntelliJ IDEA tripping? Because I'm pretty sure that this can be null and there isn't any @NotNull annotations
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot respawn player off-main, from world " + player.serverLevel().getWorld().getName() + " to world " + location.getWorld().getName());
+        else
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot respawn player off-main, respawning in world " + player.serverLevel().getWorld().getName());
+        // SparklyPaper end
         player.stopRiding(); // CraftBukkit
         this.players.remove(player);
         this.playersByName.remove(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
@@ -724,6 +732,7 @@ public abstract class PlayerList {
         ServerPlayer serverPlayer = player;
         Level fromWorld = player.level();
         player.wonGame = false;
+        serverPlayer.hasTickedAtLeastOnceInNewWorld = false; // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         // CraftBukkit end
         serverPlayer.connection = player.connection;
         serverPlayer.restoreFrom(player, keepInventory);
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 1b54cf07616a10d93e9336dbd299ba5f09678a28..9a52328f070f4991a4998cecaa8062f8b60a0fb3 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -550,7 +550,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.entityData = builder.build();
         this.setPos(0.0, 0.0, 0.0);
         this.eyeHeight = this.dimensions.eyeHeight();
-        this.despawnTime = type == EntityType.PLAYER ? -1 : level.paperConfig().entities.spawning.despawnTime.getOrDefault(type, io.papermc.paper.configuration.type.number.IntOr.Disabled.DISABLED).or(-1); // Paper - entity despawn time limit
+        this.despawnTime = level == null || type == EntityType.PLAYER ? -1 : level.paperConfig().entities.spawning.despawnTime.getOrDefault(type, io.papermc.paper.configuration.type.number.IntOr.Disabled.DISABLED).or(-1); // Paper - entity despawn time limit
     }
 
     public boolean isColliding(BlockPos pos, BlockState state) {
@@ -819,7 +819,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // CraftBukkit start
     public void postTick() {
         // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
-        if (!(this instanceof ServerPlayer) && this.isAlive()) { // Paper - don't attempt to teleport dead entities
+        if (false && !(this instanceof ServerPlayer) && this.isAlive()) { // Paper - don't attempt to teleport dead entities // SparklyPaper - parallel world ticking (see issue #9, this is executed in the server level tick for non-player entities)
             this.handlePortal();
         }
     }
@@ -1095,125 +1095,125 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             this.moveVector = movement;
         }
         try {
-        // Paper end - detailed watchdog information
-        if (this.noPhysics) {
-            this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
-        } else {
-            this.wasOnFire = this.isOnFire();
-            if (type == MoverType.PISTON) {
-                this.activatedTick = Math.max(this.activatedTick, MinecraftServer.currentTick + 20); // Paper - EAR 2
-                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, MinecraftServer.currentTick + 20);   // Paper - EAR 2
-                movement = this.limitPistonMovement(movement);
-                if (movement.equals(Vec3.ZERO)) {
-                    return;
-                }
-            }
-
-            ProfilerFiller profilerFiller = Profiler.get();
-            profilerFiller.push("move");
-            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7) {
-                movement = movement.multiply(this.stuckSpeedMultiplier);
-                this.stuckSpeedMultiplier = Vec3.ZERO;
-                this.setDeltaMovement(Vec3.ZERO);
-            }
-            // Paper start - ignore movement changes while inactive.
-            if (isTemporarilyActive && !(this instanceof ItemEntity) && movement == getDeltaMovement() && type == MoverType.SELF) {
-                setDeltaMovement(Vec3.ZERO);
-                profilerFiller.pop();
-                return;
-            }
-            // Paper end
-
-            movement = this.maybeBackOffFromEdge(movement, type);
-            Vec3 vec3 = this.collide(movement);
-            double d = vec3.lengthSqr();
-            if (d > 1.0E-7 || movement.lengthSqr() - d < 1.0E-7) {
-                if (this.fallDistance != 0.0F && d >= 1.0) {
-                    BlockHitResult blockHitResult = this.level()
-                        .clip(
-                            new ClipContext(this.position(), this.position().add(vec3), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this)
-                        );
-                    if (blockHitResult.getType() != HitResult.Type.MISS) {
-                        this.resetFallDistance();
+            // Paper end - detailed watchdog information
+            if (this.noPhysics) {
+                this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
+            } else {
+                this.wasOnFire = this.isOnFire();
+                if (type == MoverType.PISTON) {
+                    this.activatedTick = Math.max(this.activatedTick, MinecraftServer.currentTick + 20); // Paper - EAR 2
+                    this.activatedImmunityTick = Math.max(this.activatedImmunityTick, MinecraftServer.currentTick + 20);   // Paper - EAR 2
+                    movement = this.limitPistonMovement(movement);
+                    if (movement.equals(Vec3.ZERO)) {
+                        return;
                     }
                 }
 
-                this.setPos(this.getX() + vec3.x, this.getY() + vec3.y, this.getZ() + vec3.z);
-            }
-
-            profilerFiller.pop();
-            profilerFiller.push("rest");
-            boolean flag = !Mth.equal(movement.x, vec3.x);
-            boolean flag1 = !Mth.equal(movement.z, vec3.z);
-            this.horizontalCollision = flag || flag1;
-            if (Math.abs(movement.y) > 0.0 || this.isControlledByOrIsLocalPlayer()) {
-                this.verticalCollision = movement.y != vec3.y;
-                this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0;
-                this.setOnGroundWithMovement(this.verticalCollisionBelow, this.horizontalCollision, vec3);
-            }
-
-            if (this.horizontalCollision) {
-                this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3);
-            } else {
-                this.minorHorizontalCollision = false;
-            }
+                ProfilerFiller profilerFiller = Profiler.get();
+                profilerFiller.push("move");
+                if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7) {
+                    movement = movement.multiply(this.stuckSpeedMultiplier);
+                    this.stuckSpeedMultiplier = Vec3.ZERO;
+                    this.setDeltaMovement(Vec3.ZERO);
+                }
+                // Paper start - ignore movement changes while inactive.
+                if (isTemporarilyActive && !(this instanceof ItemEntity) && movement == getDeltaMovement() && type == MoverType.SELF) {
+                    setDeltaMovement(Vec3.ZERO);
+                    profilerFiller.pop();
+                    return;
+                }
+                // Paper end
+
+                movement = this.maybeBackOffFromEdge(movement, type);
+                Vec3 vec3 = this.collide(movement);
+                double d = vec3.lengthSqr();
+                if (d > 1.0E-7 || movement.lengthSqr() - d < 1.0E-7) {
+                    if (this.fallDistance != 0.0F && d >= 1.0) {
+                        BlockHitResult blockHitResult = this.level()
+                            .clip(
+                                new ClipContext(this.position(), this.position().add(vec3), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this)
+                            );
+                        if (blockHitResult.getType() != HitResult.Type.MISS) {
+                            this.resetFallDistance();
+                        }
+                    }
 
-            BlockPos onPosLegacy = this.getOnPosLegacy();
-            BlockState blockState = this.level().getBlockState(onPosLegacy);
-            if ((!this.level().isClientSide() || this.isControlledByLocalInstance()) && !this.isControlledByClient()) {
-                this.checkFallDamage(vec3.y, this.onGround(), blockState, onPosLegacy);
-            }
+                    this.setPos(this.getX() + vec3.x, this.getY() + vec3.y, this.getZ() + vec3.z);
+                }
 
-            if (this.isRemoved()) {
                 profilerFiller.pop();
-            } else {
+                profilerFiller.push("rest");
+                boolean flag = !Mth.equal(movement.x, vec3.x);
+                boolean flag1 = !Mth.equal(movement.z, vec3.z);
+                this.horizontalCollision = flag || flag1;
+                if (Math.abs(movement.y) > 0.0 || this.isControlledByOrIsLocalPlayer()) {
+                    this.verticalCollision = movement.y != vec3.y;
+                    this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0;
+                    this.setOnGroundWithMovement(this.verticalCollisionBelow, this.horizontalCollision, vec3);
+                }
+
                 if (this.horizontalCollision) {
-                    Vec3 deltaMovement = this.getDeltaMovement();
-                    this.setDeltaMovement(flag ? 0.0 : deltaMovement.x, deltaMovement.y, flag1 ? 0.0 : deltaMovement.z);
+                    this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3);
+                } else {
+                    this.minorHorizontalCollision = false;
                 }
 
-                if (this.isControlledByLocalInstance()) {
-                    Block block = blockState.getBlock();
-                    if (movement.y != vec3.y) {
-                        block.updateEntityMovementAfterFallOn(this.level(), this);
-                    }
+                BlockPos onPosLegacy = this.getOnPosLegacy();
+                BlockState blockState = this.level().getBlockState(onPosLegacy);
+                if ((!this.level().isClientSide() || this.isControlledByLocalInstance()) && !this.isControlledByClient()) {
+                    this.checkFallDamage(vec3.y, this.onGround(), blockState, onPosLegacy);
                 }
 
-                // CraftBukkit start
-                if (this.horizontalCollision && this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
-                    org.bukkit.entity.Vehicle vehicle = (org.bukkit.entity.Vehicle) this.getBukkitEntity();
-                    org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
-
-                    if (movement.x > vec3.x) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.EAST);
-                    } else if (movement.x < vec3.x) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.WEST);
-                    } else if (movement.z > vec3.z) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.SOUTH);
-                    } else if (movement.z < vec3.z) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.NORTH);
+                if (this.isRemoved()) {
+                    profilerFiller.pop();
+                } else {
+                    if (this.horizontalCollision) {
+                        Vec3 deltaMovement = this.getDeltaMovement();
+                        this.setDeltaMovement(flag ? 0.0 : deltaMovement.x, deltaMovement.y, flag1 ? 0.0 : deltaMovement.z);
                     }
 
-                    if (!bl.getType().isAir()) {
-                        org.bukkit.event.vehicle.VehicleBlockCollisionEvent event = new org.bukkit.event.vehicle.VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
-                        this.level.getCraftServer().getPluginManager().callEvent(event);
+                    if (this.isControlledByLocalInstance()) {
+                        Block block = blockState.getBlock();
+                        if (movement.y != vec3.y) {
+                            block.updateEntityMovementAfterFallOn(this.level(), this);
+                        }
                     }
-                }
-                // CraftBukkit end
 
-                if (!this.level().isClientSide() || this.isControlledByLocalInstance()) {
-                    Entity.MovementEmission movementEmission = this.getMovementEmission();
-                    if (movementEmission.emitsAnything() && !this.isPassenger()) {
-                        this.applyMovementEmissionAndPlaySound(movementEmission, vec3, onPosLegacy, blockState);
+                    // CraftBukkit start
+                    if (this.horizontalCollision && this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
+                        org.bukkit.entity.Vehicle vehicle = (org.bukkit.entity.Vehicle) this.getBukkitEntity();
+                        org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
+
+                        if (movement.x > vec3.x) {
+                            bl = bl.getRelative(org.bukkit.block.BlockFace.EAST);
+                        } else if (movement.x < vec3.x) {
+                            bl = bl.getRelative(org.bukkit.block.BlockFace.WEST);
+                        } else if (movement.z > vec3.z) {
+                            bl = bl.getRelative(org.bukkit.block.BlockFace.SOUTH);
+                        } else if (movement.z < vec3.z) {
+                            bl = bl.getRelative(org.bukkit.block.BlockFace.NORTH);
+                        }
+
+                        if (!bl.getType().isAir()) {
+                            org.bukkit.event.vehicle.VehicleBlockCollisionEvent event = new org.bukkit.event.vehicle.VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
+                            this.level.getCraftServer().getPluginManager().callEvent(event);
+                        }
                     }
-                }
+                    // CraftBukkit end
 
-                float blockSpeedFactor = this.getBlockSpeedFactor();
-                this.setDeltaMovement(this.getDeltaMovement().multiply(blockSpeedFactor, 1.0, blockSpeedFactor));
-                profilerFiller.pop();
+                    if (!this.level().isClientSide() || this.isControlledByLocalInstance()) {
+                        Entity.MovementEmission movementEmission = this.getMovementEmission();
+                        if (movementEmission.emitsAnything() && !this.isPassenger()) {
+                            this.applyMovementEmissionAndPlaySound(movementEmission, vec3, onPosLegacy, blockState);
+                        }
+                    }
+
+                    float blockSpeedFactor = this.getBlockSpeedFactor();
+                    this.setDeltaMovement(this.getDeltaMovement().multiply(blockSpeedFactor, 1.0, blockSpeedFactor));
+                    profilerFiller.pop();
+                }
             }
-        }
-        // Paper start - detailed watchdog information
+            // Paper start - detailed watchdog information
         } finally {
             synchronized (this.posLock) { // Paper
                 this.moveVector = null;
@@ -1364,8 +1364,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             } else {
                 BlockState blockState = this.level().getBlockState(blockPos);
                 return (!(yOffset <= 0.5) || !blockState.is(BlockTags.FENCES))
-                        && !blockState.is(BlockTags.WALLS)
-                        && !(blockState.getBlock() instanceof FenceGateBlock)
+                    && !blockState.is(BlockTags.WALLS)
+                    && !(blockState.getBlock() instanceof FenceGateBlock)
                     ? blockPos.atY(Mth.floor(this.position.y - yOffset))
                     : blockPos;
             }
@@ -2394,7 +2394,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 } else {
                     compound.put("Pos", this.newDoubleList(this.getX(), this.getY(), this.getZ()));
                 }
-             }
+            }
             // CraftBukkit end
 
             Vec3 deltaMovement = this.getDeltaMovement();
@@ -3141,8 +3141,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             Entity orig = craft == null ? null : craft.getHandle();
             if (this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
                 org.bukkit.event.vehicle.VehicleExitEvent event = new org.bukkit.event.vehicle.VehicleExitEvent(
-                        (org.bukkit.entity.Vehicle) this.getBukkitEntity(),
-                        (org.bukkit.entity.LivingEntity) passenger.getBukkitEntity(), !suppressCancellation // Paper - Force entity dismount during teleportation
+                    (org.bukkit.entity.Vehicle) this.getBukkitEntity(),
+                    (org.bukkit.entity.LivingEntity) passenger.getBukkitEntity(), !suppressCancellation // Paper - Force entity dismount during teleportation
                 );
                 // Suppress during worldgen
                 if (this.valid) {
@@ -3511,10 +3511,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             pluginManager.callEvent(entityCombustEvent);
             if (!entityCombustEvent.isCancelled()) {
                 this.igniteForSeconds(entityCombustEvent.getDuration(), false);
-            // Paper start - fix EntityCombustEvent cancellation
+                // Paper start - fix EntityCombustEvent cancellation
             } else {
                 this.setRemainingFireTicks(this.remainingFireTicks - 1);
-            // Paper end - fix EntityCombustEvent cancellation
+                // Paper end - fix EntityCombustEvent cancellation
             }
             // CraftBukkit end
         }
@@ -3661,32 +3661,32 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         String string = this.level() == null ? "~NULL~" : this.level().toString();
         return this.removalReason != null
             ? String.format(
-                Locale.ROOT,
-                "%s['%s'/%d, uuid='%s', l='%s', x=%.2f, y=%.2f, z=%.2f, cpos=%s, tl=%d, v=%b, removed=%s]", // Paper - add more info
-                this.getClass().getSimpleName(),
-                this.getName().getString(),
-                this.id,
-                this.uuid, // Paper - add more info
-                string,
-                this.getX(),
-                this.getY(),
-                this.getZ(),
-                this.chunkPosition(), this.tickCount, this.valid, // Paper - add more info
-                this.removalReason
-            )
+            Locale.ROOT,
+            "%s['%s'/%d, uuid='%s', l='%s', x=%.2f, y=%.2f, z=%.2f, cpos=%s, tl=%d, v=%b, removed=%s]", // Paper - add more info
+            this.getClass().getSimpleName(),
+            this.getName().getString(),
+            this.id,
+            this.uuid, // Paper - add more info
+            string,
+            this.getX(),
+            this.getY(),
+            this.getZ(),
+            this.chunkPosition(), this.tickCount, this.valid, // Paper - add more info
+            this.removalReason
+        )
             : String.format(
-                Locale.ROOT,
-                "%s['%s'/%d, uuid='%s', l='%s', x=%.2f, y=%.2f, z=%.2f, cpos=%s, tl=%d, v=%b]", // Paper - add more info
-                this.getClass().getSimpleName(),
-                this.getName().getString(),
-                this.id,
-                this.uuid, // Paper - add more info
-                string,
-                this.getX(),
-                this.getY(),
-                this.getZ(),
-                this.chunkPosition(), this.tickCount, this.valid // Paper - add more info
-            );
+            Locale.ROOT,
+            "%s['%s'/%d, uuid='%s', l='%s', x=%.2f, y=%.2f, z=%.2f, cpos=%s, tl=%d, v=%b]", // Paper - add more info
+            this.getClass().getSimpleName(),
+            this.getName().getString(),
+            this.id,
+            this.uuid, // Paper - add more info
+            string,
+            this.getX(),
+            this.getY(),
+            this.getZ(),
+            this.chunkPosition(), this.tickCount, this.valid // Paper - add more info
+        );
     }
 
     public final boolean isInvulnerableToBase(DamageSource damageSource) {
@@ -3805,6 +3805,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     private Entity teleportCrossDimension(ServerLevel level, TeleportTransition teleportTransition) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(level, "Cannot teleport entity to another world off-main, from world " + this.level.getWorld().getName() + " to world " + level.getWorld().getName()); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         List<Entity> passengers = this.getPassengers();
         List<Entity> list = new ArrayList<>(passengers.size());
         this.ejectPassengers();
@@ -4185,11 +4186,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public final void setBoundingBox(AABB bb) {
         // CraftBukkit start - block invalid bounding boxes
         double minX = bb.minX,
-                minY = bb.minY,
-                minZ = bb.minZ,
-                maxX = bb.maxX,
-                maxY = bb.maxY,
-                maxZ = bb.maxZ;
+            minY = bb.minY,
+            minZ = bb.minZ,
+            maxX = bb.maxX,
+            maxY = bb.maxY,
+            maxZ = bb.maxZ;
         double len = bb.maxX - bb.minX;
         if (len < 0) maxX = minX;
         if (len > 64) maxX = minX + 64.0;
@@ -4681,7 +4682,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     public void setDeltaMovement(Vec3 deltaMovement) {
         synchronized (this.posLock) { // Paper - detailed watchdog information
-        this.deltaMovement = deltaMovement;
+            this.deltaMovement = deltaMovement;
         } // Paper - detailed watchdog information
     }
 
@@ -4789,7 +4790,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // Paper end - Fix MC-4
         if (this.position.x != x || this.position.y != y || this.position.z != z) {
             synchronized (this.posLock) { // Paper - detailed watchdog information
-            this.position = new Vec3(x, y, z);
+                this.position = new Vec3(x, y, z);
             } // Paper - detailed watchdog information
             int floor = Mth.floor(x);
             int floor1 = Mth.floor(y);
diff --git a/net/minecraft/world/inventory/AbstractContainerMenu.java b/net/minecraft/world/inventory/AbstractContainerMenu.java
index 50af953a4698a3c6e16b840fab764dd733b3fbc9..ebc60d94dfb9a48086ceea83b9776941aec06b0f 100644
--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -91,6 +91,7 @@ public abstract class AbstractContainerMenu {
     }
     public void startOpen() {}
     // CraftBukkit end
+    public Throwable containerCreationStacktrace; // SparklyPaper - parallel world ticking (debugging)
 
     protected AbstractContainerMenu(@Nullable MenuType<?> menuType, int containerId) {
         this.menuType = menuType;
@@ -645,7 +646,7 @@ public abstract class AbstractContainerMenu {
         FeatureFlagSet featureFlagSet = player.level().enabledFeatures();
         return carriedItem.isItemEnabled(featureFlagSet) && carriedItem.overrideStackedOnOther(slot, action, player)
             || clickedItem.isItemEnabled(featureFlagSet)
-                && clickedItem.overrideOtherStackedOnMe(carriedItem, slot, action, player, this.createCarriedSlotAccess());
+            && clickedItem.overrideOtherStackedOnMe(carriedItem, slot, action, player, this.createCarriedSlotAccess());
     }
 
     private SlotAccess createCarriedSlotAccess() {
@@ -749,14 +750,14 @@ public abstract class AbstractContainerMenu {
                         stack.setCount(0);
                         item.setCount(i1);
                         if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
-                        slot.setChanged();
+                            slot.setChanged();
                         } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag = true;
                     } else if (item.getCount() < maxStackSize) {
                         stack.shrink(maxStackSize - item.getCount());
                         item.setCount(maxStackSize);
-                         if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
-                        slot.setChanged();
+                        if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
+                            slot.setChanged();
                         } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag = true;
                     }
@@ -791,9 +792,9 @@ public abstract class AbstractContainerMenu {
                     if (isCheck) {
                         stack.shrink(Math.min(stack.getCount(), i1));
                     } else {
-                    // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
-                    slotx.setByPlayer(stack.split(Math.min(stack.getCount(), i1)));
-                    slotx.setChanged();
+                        // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
+                        slotx.setByPlayer(stack.split(Math.min(stack.getCount(), i1)));
+                        slotx.setChanged();
                     } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                     flag = true;
                     break;
diff --git a/net/minecraft/world/item/ItemStack.java b/net/minecraft/world/item/ItemStack.java
index 76f50437396f8f856381d0fbef52953ef7c263f6..7b9ec93ca8618cef1db1e4181f67080e694ab39b 100644
--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -160,7 +160,7 @@ public final class ItemStack implements DataComponentHolder {
                 boolean prev = net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.get();
                 try (final io.papermc.paper.util.SafeAutoClosable ignored = io.papermc.paper.util.ItemObfuscationSession.withContext(c -> c.itemStack(value))) { // pass the itemstack as context to the obfuscation session
                     net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(true);
-                DataComponentPatch.STREAM_CODEC.encode(buffer, value.components.asPatch());
+                    DataComponentPatch.STREAM_CODEC.encode(buffer, value.components.asPatch());
                 } finally {
                     net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(prev);
                 }
@@ -407,8 +407,8 @@ public final class ItemStack implements DataComponentHolder {
             if (interactionResult.consumesAction() && serverLevel.captureTreeGeneration && !serverLevel.capturedBlockStates.isEmpty()) {
                 serverLevel.captureTreeGeneration = false;
                 org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(clickedPos, serverLevel.getWorld());
-                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                net.minecraft.world.level.block.SaplingBlock.treeType = null;
+                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(null);
                 List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
                 serverLevel.capturedBlockStates.clear();
                 org.bukkit.event.world.StructureGrowEvent structureEvent = null;
@@ -562,10 +562,10 @@ public final class ItemStack implements DataComponentHolder {
         InteractionResult interactionResult = this.getItem().use(level, player, hand);
         return (InteractionResult)(flag && interactionResult instanceof InteractionResult.Success success
             ? success.heldItemTransformedTo(
-                success.heldItemTransformedTo() == null
-                    ? this.applyAfterUseComponentSideEffects(player, itemStack)
-                    : success.heldItemTransformedTo().applyAfterUseComponentSideEffects(player, itemStack)
-            )
+            success.heldItemTransformedTo() == null
+                ? this.applyAfterUseComponentSideEffects(player, itemStack)
+                : success.heldItemTransformedTo().applyAfterUseComponentSideEffects(player, itemStack)
+        )
             : interactionResult);
     }
 
@@ -1175,8 +1175,8 @@ public final class ItemStack implements DataComponentHolder {
 
         double d;
         if (modifier.operation() == AttributeModifier.Operation.ADD_MULTIPLIED_BASE || modifier.operation() == AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL
-            )
-         {
+        )
+        {
             d = amount * 100.0;
         } else if (attribute.is(Attributes.KNOCKBACK_RESISTANCE)) {
             d = amount * 10.0;
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 1dbe7c7c1051c3972105534a07ce50d4cf98fc85..99fefeeb29c0e7181a78c21b2b149990af8b7efe 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -170,6 +170,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     // Paper end - add paper world config
 
     public final io.papermc.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
+    public io.papermc.paper.redstone.RedstoneWireTurbo turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((net.minecraft.world.level.block.RedStoneWireBlock) net.minecraft.world.level.block.Blocks.REDSTONE_WIRE); // SparklyPaper - parallel world ticking (moved to world)
     public static BlockPos lastPhysicsProblem; // Spigot
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
@@ -1098,6 +1099,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, int flags, int recursionLeft) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, pos, "Updating block asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // CraftBukkit start - tree generation
         if (this.captureTreeGeneration) {
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
@@ -1481,8 +1483,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             } else if (runsNormally && this.shouldTickBlocksAt(tickingBlockEntity.getPos())) {
                 tickingBlockEntity.tick();
                 // Paper start - rewrite chunk system
-                if ((++tickedEntities & 7) == 0) {
-                    ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
+                if ((++tickedEntities & 7) == 0) { // TO-DO: fix empty if
+                    // ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks(); // SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
                 }
                 // Paper end - rewrite chunk system
             }
@@ -1505,7 +1507,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
             // Paper end - Prevent block entity and entity crashes
         }
-        this.moonrise$midTickTasks(); // Paper - rewrite chunk system
+        // this.moonrise$midTickTasks(); // Paper - rewrite chunk system // SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
     }
 
     // Paper start - Option to prevent armor stands from doing entity lookups
@@ -1648,6 +1650,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Nullable
     public BlockEntity getBlockEntity(BlockPos pos, boolean validate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThreadOrAsyncThread((ServerLevel) this, "Cannot read world asynchronously"); // SparklyPaper - parallel world ticking
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
         if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(pos)) != null) {
@@ -1665,6 +1668,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel) this, "Cannot modify world asynchronously"); // SparklyPaper - parallel world ticking
         BlockPos blockPos = blockEntity.getBlockPos();
         if (!this.isOutsideBuildHeight(blockPos)) {
             // CraftBukkit start
@@ -1749,6 +1753,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AABB boundingBox, Predicate<? super Entity> predicate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, boundingBox, "Cannot getEntities asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         Profiler.get().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
 
@@ -2061,8 +2066,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public abstract RecipeAccess recipeAccess();
 
     public BlockPos getBlockRandomPos(int x, int y, int z, int yMask) {
-        this.randValue = this.randValue * 3 + 1013904223;
-        int i = this.randValue >> 2;
+        // this.randValue = this.randValue * 3 + 1013904223;
+        int i = this.random.nextInt() >> 2; // SparklyPaper - parallel world ticking
         return new BlockPos(x + (i & 15), y + (i >> 16 & yMask), z + (i >> 8 & 15));
     }
 
diff --git a/net/minecraft/world/level/block/DispenserBlock.java b/net/minecraft/world/level/block/DispenserBlock.java
index e0a4d41e5bcf144ea4c10d6f633c3a95ed2c5aec..6fecddc21a36aadef9d82a9ae132b0de2dc477cd 100644
--- a/net/minecraft/world/level/block/DispenserBlock.java
+++ b/net/minecraft/world/level/block/DispenserBlock.java
@@ -50,7 +50,8 @@ public class DispenserBlock extends BaseEntityBlock {
     private static final DefaultDispenseItemBehavior DEFAULT_BEHAVIOR = new DefaultDispenseItemBehavior();
     public static final Map<Item, DispenseItemBehavior> DISPENSER_REGISTRY = new IdentityHashMap<>();
     private static final int TRIGGER_DURATION = 4;
-    public static boolean eventFired = false; // CraftBukkit
+    // public static boolean eventFired = false; // CraftBukkit // SparklyPaper - parallel world ticking
+    public static ThreadLocal<Boolean> eventFired = ThreadLocal.withInitial(() -> Boolean.FALSE); // SparklyPaper - parallel world ticking
 
     @Override
     public MapCodec<? extends DispenserBlock> codec() {
@@ -88,15 +89,15 @@ public class DispenserBlock extends BaseEntityBlock {
             int randomSlot = dispenserBlockEntity.getRandomSlot(level.random);
             if (randomSlot < 0) {
                 if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFailedDispenseEvent(level, pos)) { // Paper - Add BlockFailedDispenseEvent
-                level.levelEvent(1001, pos, 0);
-                level.gameEvent(GameEvent.BLOCK_ACTIVATE, pos, GameEvent.Context.of(dispenserBlockEntity.getBlockState()));
+                    level.levelEvent(1001, pos, 0);
+                    level.gameEvent(GameEvent.BLOCK_ACTIVATE, pos, GameEvent.Context.of(dispenserBlockEntity.getBlockState()));
                 } // Paper - Add BlockFailedDispenseEvent
             } else {
                 ItemStack item = dispenserBlockEntity.getItem(randomSlot);
                 DispenseItemBehavior dispenseMethod = this.getDispenseMethod(level, item);
                 if (dispenseMethod != DispenseItemBehavior.NOOP) {
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockPreDispenseEvent(level, pos, item, randomSlot)) return; // Paper - Add BlockPreDispenseEvent
-                    DispenserBlock.eventFired = false; // CraftBukkit - reset event status
+                    DispenserBlock.eventFired.set(Boolean.FALSE); // CraftBukkit - reset event status // SparklyPaper - parallel world ticking
                     dispenserBlockEntity.setItem(randomSlot, dispenseMethod.dispense(blockSource, item));
                 }
             }
diff --git a/net/minecraft/world/level/block/FungusBlock.java b/net/minecraft/world/level/block/FungusBlock.java
index 85f0eac75784565c658c5178c544f969db3d6f54..bfa0b1f72497cefecc112d9f484896edc9ec6f36 100644
--- a/net/minecraft/world/level/block/FungusBlock.java
+++ b/net/minecraft/world/level/block/FungusBlock.java
@@ -76,9 +76,9 @@ public class FungusBlock extends BushBlock implements BonemealableBlock {
             // CraftBukkit start
             .map((value) -> {
                 if (this == Blocks.WARPED_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.WARPED_FUNGUS;
+                    SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.WARPED_FUNGUS); // SparklyPaper - parallel world ticking
                 } else if (this == Blocks.CRIMSON_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.CRIMSON_FUNGUS;
+                    SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.CRIMSON_FUNGUS); // SparklyPaper - parallel world ticking
                 }
                 return value;
             })
diff --git a/net/minecraft/world/level/block/MushroomBlock.java b/net/minecraft/world/level/block/MushroomBlock.java
index 904369f4d7db41026183f2de7c96c2f0f4dc204d..1ef0cf368fe9de49c7ba0ba3b647108b5bbe3e48 100644
--- a/net/minecraft/world/level/block/MushroomBlock.java
+++ b/net/minecraft/world/level/block/MushroomBlock.java
@@ -94,7 +94,7 @@ public class MushroomBlock extends BushBlock implements BonemealableBlock {
             return false;
         } else {
             level.removeBlock(pos, false);
-            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM; // CraftBukkit
+            SaplingBlock.treeTypeRT.set((this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM); // CraftBukkit // SparklyPaper - parallel world ticking
             if (optional.get().value().place(level, level.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
diff --git a/net/minecraft/world/level/block/RedStoneWireBlock.java b/net/minecraft/world/level/block/RedStoneWireBlock.java
index 12c9d60314c99fb65e640d255a2d0c6b7790ad4d..d9fdb75485a41641f516f0134ca941733a48dd36 100644
--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -292,7 +292,7 @@ public class RedStoneWireBlock extends Block {
 
     // Paper start - Optimize redstone (Eigencraft)
     // The bulk of the new functionality is found in RedstoneWireTurbo.java
-    io.papermc.paper.redstone.RedstoneWireTurbo turbo = new io.papermc.paper.redstone.RedstoneWireTurbo(this);
+    // io.papermc.paper.redstone.RedstoneWireTurbo turbo = new io.papermc.paper.redstone.RedstoneWireTurbo(this);
 
     /*
      * Modified version of pre-existing updateSurroundingRedstone, which is called from
@@ -308,7 +308,7 @@ public class RedStoneWireBlock extends Block {
             if (orientation != null) {
                 source = pos.relative(orientation.getFront().getOpposite());
             }
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            worldIn.turbo.updateSurroundingRedstone(worldIn, pos, state, source); // SparklyPaper - parallel world ticking
             return;
         }
         updatePowerStrength(worldIn, pos, state, orientation, blockAdded);
@@ -336,7 +336,7 @@ public class RedStoneWireBlock extends Block {
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS)) {
-                    turbo.updateNeighborShapes(level, pos, state);
+                    level.turbo.updateNeighborShapes(level, pos, state); // SparklyPaper - parallel world ticking
                 }
             }
         }
diff --git a/net/minecraft/world/level/block/SaplingBlock.java b/net/minecraft/world/level/block/SaplingBlock.java
index e014f052e9b0f5ca6b28044e2389782b7d0e0cb8..c9091b66f5ddf7bd7145becdfc5e252163b03300 100644
--- a/net/minecraft/world/level/block/SaplingBlock.java
+++ b/net/minecraft/world/level/block/SaplingBlock.java
@@ -26,7 +26,7 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
     protected static final float AABB_OFFSET = 6.0F;
     protected static final VoxelShape SHAPE = Block.box(2.0, 0.0, 2.0, 14.0, 12.0, 14.0);
     protected final TreeGrower treeGrower;
-    public static org.bukkit.TreeType treeType; // CraftBukkit
+    public static final ThreadLocal<org.bukkit.TreeType> treeTypeRT = new ThreadLocal<>(); // CraftBukkit // SparklyPaper - parallel world ticking (from Folia)
 
     @Override
     public MapCodec<? extends SaplingBlock> codec() {
@@ -63,8 +63,8 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
                 this.treeGrower.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
                 level.captureTreeGeneration = false;
                 if (!level.capturedBlockStates.isEmpty()) {
-                    org.bukkit.TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    org.bukkit.TreeType treeType = SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                    SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level.getWorld());
                     java.util.List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(level.capturedBlockStates.values());
                     level.capturedBlockStates.clear();
diff --git a/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java b/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
index 26db603ed681a6c302596627d4dd5bf8a9bafc4e..107f16154b8002c4ea3187682266cc39a45a4d26 100644
--- a/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
@@ -77,6 +77,12 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
         return canUnlock(player, code, displayName, null);
     }
     public static boolean canUnlock(Player player, LockCode code, Component displayName, @Nullable BlockEntity blockEntity) {
+        // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+        if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer && blockEntity != null && blockEntity.getLevel() != serverPlayer.serverLevel()) {
+            net.minecraft.server.MinecraftServer.LOGGER.warn("Player " + serverPlayer.getScoreboardName() + " (" + serverPlayer.getStringUUID() + ") attempted to open a BlockEntity @ " + blockEntity.getLevel().getWorld().getName() + " " + blockEntity.getBlockPos().getX() + ", " + blockEntity.getBlockPos().getY() + ", " + blockEntity.getBlockPos().getZ() + " while they were in a different world " + serverPlayer.level().getWorld().getName() + " than the block themselves!");
+            return false;
+        }
+        // SparklyPaper end
         if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer && blockEntity != null && blockEntity.getLevel() != null && blockEntity.getLevel().getBlockEntity(blockEntity.getBlockPos()) == blockEntity) {
             final org.bukkit.block.Block block = org.bukkit.craftbukkit.block.CraftBlock.at(blockEntity.getLevel(), blockEntity.getBlockPos());
             net.kyori.adventure.text.Component lockedMessage = net.kyori.adventure.text.Component.translatable("container.isLocked", io.papermc.paper.adventure.PaperAdventure.asAdventure(displayName));
@@ -97,14 +103,14 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
                 return true;
             }
         } else { // logic below is replaced by logic above
-        // Paper end - Add BlockLockCheckEvent
-        if (!player.isSpectator() && !code.unlocksWith(player.getMainHandItem())) {
-            player.displayClientMessage(Component.translatable("container.isLocked", displayName), true); // Paper - diff on change
-            player.playNotifySound(SoundEvents.CHEST_LOCKED, SoundSource.BLOCKS, 1.0F, 1.0F);
-            return false;
-        } else {
-            return true;
-        }
+            // Paper end - Add BlockLockCheckEvent
+            if (!player.isSpectator() && !code.unlocksWith(player.getMainHandItem())) {
+                player.displayClientMessage(Component.translatable("container.isLocked", displayName), true); // Paper - diff on change
+                player.playNotifySound(SoundEvents.CHEST_LOCKED, SoundSource.BLOCKS, 1.0F, 1.0F);
+                return false;
+            } else {
+                return true;
+            }
         } // Paper - Add BlockLockCheckEvent
     }
 
diff --git a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index 1638eccef431fb68775af624110f1968f0c6dabd..a1096b17ddd4f02cdbe5615030803df88d200ed7 100644
--- a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -43,9 +43,9 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
     // Paper end - Fix NPE in SculkBloomEvent world access
 
     public static void serverTick(Level level, BlockPos pos, BlockState state, SculkCatalystBlockEntity sculkCatalyst) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = sculkCatalyst.getBlockPos(); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(pos); // SparklyPaper - parallel world ticking // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
         sculkCatalyst.catalystListener.getSculkSpreader().updateCursors(level, pos, level.getRandom(), true);
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = null; // CraftBukkit
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(null); // SparklyPaper - parallel world ticking // CraftBukkit
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/grower/TreeGrower.java b/net/minecraft/world/level/block/grower/TreeGrower.java
index cf7311c507de09a8f89934e430b2201e8bdffe51..2ad658fa8e42f26a37fed9faff421827cb72607b 100644
--- a/net/minecraft/world/level/block/grower/TreeGrower.java
+++ b/net/minecraft/world/level/block/grower/TreeGrower.java
@@ -204,55 +204,59 @@ public final class TreeGrower {
     // CraftBukkit start
     private void setTreeType(Holder<ConfiguredFeature<?, ?>> holder) {
         ResourceKey<ConfiguredFeature<?, ?>> treeFeature = holder.unwrapKey().get();
+        // SparklyPaper start - parallel world ticking
+        org.bukkit.TreeType treeType;
         if (treeFeature == TreeFeatures.OAK || treeFeature == TreeFeatures.OAK_BEES_005) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TREE;
+            treeType = org.bukkit.TreeType.TREE;
         } else if (treeFeature == TreeFeatures.HUGE_RED_MUSHROOM) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.RED_MUSHROOM;
+            treeType = org.bukkit.TreeType.RED_MUSHROOM;
         } else if (treeFeature == TreeFeatures.HUGE_BROWN_MUSHROOM) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BROWN_MUSHROOM;
+            treeType = org.bukkit.TreeType.BROWN_MUSHROOM;
         } else if (treeFeature == TreeFeatures.JUNGLE_TREE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.COCOA_TREE;
+            treeType = org.bukkit.TreeType.COCOA_TREE;
         } else if (treeFeature == TreeFeatures.JUNGLE_TREE_NO_VINE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SMALL_JUNGLE;
+            treeType = org.bukkit.TreeType.SMALL_JUNGLE;
         } else if (treeFeature == TreeFeatures.PINE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_REDWOOD;
+            treeType = org.bukkit.TreeType.TALL_REDWOOD;
         } else if (treeFeature == TreeFeatures.SPRUCE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.REDWOOD;
+            treeType = org.bukkit.TreeType.REDWOOD;
         } else if (treeFeature == TreeFeatures.ACACIA) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.ACACIA;
+            treeType = org.bukkit.TreeType.ACACIA;
         } else if (treeFeature == TreeFeatures.BIRCH || treeFeature == TreeFeatures.BIRCH_BEES_005) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIRCH;
+            treeType = org.bukkit.TreeType.BIRCH;
         } else if (treeFeature == TreeFeatures.SUPER_BIRCH_BEES_0002) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_BIRCH;
+            treeType = org.bukkit.TreeType.TALL_BIRCH;
         } else if (treeFeature == TreeFeatures.SWAMP_OAK) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SWAMP;
+            treeType = org.bukkit.TreeType.SWAMP;
         } else if (treeFeature == TreeFeatures.FANCY_OAK || treeFeature == TreeFeatures.FANCY_OAK_BEES_005) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIG_TREE;
+            treeType = org.bukkit.TreeType.BIG_TREE;
         } else if (treeFeature == TreeFeatures.JUNGLE_BUSH) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE_BUSH;
+            treeType = org.bukkit.TreeType.JUNGLE_BUSH;
         } else if (treeFeature == TreeFeatures.DARK_OAK) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.DARK_OAK;
+            treeType = org.bukkit.TreeType.DARK_OAK;
         } else if (treeFeature == TreeFeatures.MEGA_SPRUCE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_REDWOOD;
+            treeType = org.bukkit.TreeType.MEGA_REDWOOD;
         } else if (treeFeature == TreeFeatures.MEGA_PINE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_PINE;
+            treeType = org.bukkit.TreeType.MEGA_PINE;
         } else if (treeFeature == TreeFeatures.MEGA_JUNGLE_TREE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE;
+            treeType = org.bukkit.TreeType.JUNGLE;
         } else if (treeFeature == TreeFeatures.AZALEA_TREE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.AZALEA;
+            treeType = org.bukkit.TreeType.AZALEA;
         } else if (treeFeature == TreeFeatures.MANGROVE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MANGROVE;
+            treeType = org.bukkit.TreeType.MANGROVE;
         } else if (treeFeature == TreeFeatures.TALL_MANGROVE) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_MANGROVE;
+            treeType = org.bukkit.TreeType.TALL_MANGROVE;
         } else if (treeFeature == TreeFeatures.CHERRY || treeFeature == TreeFeatures.CHERRY_BEES_005) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.CHERRY;
+            treeType = org.bukkit.TreeType.CHERRY;
         } else if (treeFeature == TreeFeatures.PALE_OAK || treeFeature == TreeFeatures.PALE_OAK_BONEMEAL) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK;
+            treeType = org.bukkit.TreeType.PALE_OAK;
         } else if (treeFeature == TreeFeatures.PALE_OAK_CREAKING) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK_CREAKING;
+            treeType = org.bukkit.TreeType.PALE_OAK_CREAKING;
         } else {
             throw new IllegalArgumentException("Unknown tree generator " + treeFeature);
         }
+        net.minecraft.world.level.block.SaplingBlock.treeTypeRT.set(treeType); // SparklyPaper - parallel world ticking
+        // SparklyPaper end
     }
     // CraftBukkit end
 }
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index 761fdcd4a4e18f45547afd8edff44f61c6eeacb4..17fb7161171cbe44d145cf0065826f49183880b0 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -360,6 +360,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
 
     @Nullable
     public BlockState setBlockState(BlockPos pos, BlockState state, boolean isMoving, boolean doPlace) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, pos, "Updating block asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // CraftBukkit end
         int y = pos.getY();
         LevelChunkSection section = this.getSection(this.getSectionIndex(y));
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..24f9632e73d73c2ad68ebf30eb0e4cca7befae2d 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -10,17 +10,26 @@ import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
     private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    // SparklyPaper start - parallel world ticking
+    // Used to track async entity additions/removals/loops
+    private final net.minecraft.server.level.ServerLevel serverLevel;
+    public EntityTickList(net.minecraft.server.level.ServerLevel serverLevel) {
+        this.serverLevel = serverLevel;
+    }
+    // SparklyPaper end
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
 
     public void add(Entity entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist addition"); // Paper // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
     }
 
     public void remove(Entity entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist removal"); // Paper // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
     }
@@ -30,6 +39,7 @@ public class EntityTickList {
     }
 
     public void forEach(Consumer<Entity> entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverLevel, "Asynchronous entity ticklist iteration"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // Paper start - rewrite chunk system
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
diff --git a/net/minecraft/world/level/saveddata/maps/MapIndex.java b/net/minecraft/world/level/saveddata/maps/MapIndex.java
index ffe604f8397a002800e6ecc2f878d0f6f1c98703..78167e3f4eff6f2f43c70c13cbbcdd92ef8a40e7 100644
--- a/net/minecraft/world/level/saveddata/maps/MapIndex.java
+++ b/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -34,17 +34,20 @@ public class MapIndex extends SavedData {
 
     @Override
     public CompoundTag save(CompoundTag tag, HolderLookup.Provider registries) {
-        for (Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
-            tag.putInt(entry.getKey(), entry.getIntValue());
-        }
-
+        synchronized (this.usedAuxIds) { // SparklyPaper start - make map data thread-safe
+            for (Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
+                tag.putInt(entry.getKey(), entry.getIntValue());
+            }
+        } // SparklyPaper end - make map data thread-safe
         return tag;
     }
 
     public MapId getFreeAuxValueForMap() {
-        int i = this.usedAuxIds.getInt("map") + 1;
-        this.usedAuxIds.put("map", i);
-        this.setDirty();
-        return new MapId(i);
+        synchronized (this.usedAuxIds) { // SparklyPaper start - make map data thread-safe
+            int i = this.usedAuxIds.getInt("map") + 1;
+            this.usedAuxIds.put("map", i);
+            this.setDirty();
+            return new MapId(i);
+        } // SparklyPaper end - make map data thread-safe
     }
 }
